---
title: 共享 250 的 HoloLens 和沉浸式耳机 MR
description: 遵循此编码使用 Unity、 Visual Studio、 HoloLens、 和 Windows Mixed Reality 耳机若要了解详细信息的共享全息混合的现实设备之间的演练。
author: keveleigh
ms.author: kurtie
ms.date: 03/21/2018
ms.topic: article
keywords: holotoolkit，mixedrealitytoolkit，mixedrealitytoolkit unity，令人着迷，动作控制器、 共享、 xbox 控制器、 网络、 跨设备
ms.openlocfilehash: 9e1cb0d168b8bf830b4477190516cd19caef7972
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/12/2019
ms.locfileid: "59590203"
---
>[!NOTE]
><span data-ttu-id="a1ef6-104">混合现实学院教程均针对具有 HoloLens （第 1 代） 和混合现实沉浸式耳机记住。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-104">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="a1ef6-105">在这种情况下，我们认为很重要的开发人员仍在查找中针对这些设备进行开发指南将这些教程保留在原处。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-105">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="a1ef6-106">这些教程将**_不_** 使用最新工具集或用于 HoloLens 2 的交互进行更新。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-106">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="a1ef6-107">它们都将保留在受支持的设备上继续工作。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-107">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="a1ef6-108">将一系列新的将在将来发布的教程将演示如何开发适用于 HoloLens 2。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-108">There will be a new series of tutorials that will be posted in the future that will demonstrate how to develop for HoloLens 2.</span></span>  <span data-ttu-id="a1ef6-109">在发布时，将使用这些教程的链接更新此通知。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-109">This notice will be updated with a link to those tutorials when they are posted.</span></span>

<br>

# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="a1ef6-110">共享 250 MR:HoloLens 和沉浸式耳机</span><span class="sxs-lookup"><span data-stu-id="a1ef6-110">MR Sharing 250: HoloLens and immersive headsets</span></span>

<span data-ttu-id="a1ef6-111">灵活的通用 Windows 平台 (UWP) 中，很容易创建跨越多个设备的应用程序。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-111">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="a1ef6-112">使用这种灵活性，我们可以创建利用优势的每个设备的体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-112">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="a1ef6-113">本教程将介绍基本的共享的体验 HoloLens 和 Windows Mixed Reality 沉浸式耳机上运行。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-113">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="a1ef6-114">最初，此内容已传递华盛顿州西雅图市的 Microsoft Build 2017 大会上。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-114">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="a1ef6-115">**在本教程中，我们将：**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-115">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="a1ef6-116">设置使用 UNET 的网络。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-116">Setup a network using UNET.</span></span>
* <span data-ttu-id="a1ef6-117">在混合的现实设备之间共享全息。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-117">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="a1ef6-118">建立应用程序，具体取决于使用混合的现实设备的不同视图。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-118">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="a1ef6-119">创建其中 HoloLens 用户指南沉浸式耳机用户可通过一些简单的填数游戏的共享的体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-119">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="a1ef6-120">设备支持</span><span class="sxs-lookup"><span data-stu-id="a1ef6-120">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="a1ef6-121">课程</span><span class="sxs-lookup"><span data-stu-id="a1ef6-121">Course</span></span></th><th style="width:150px"> <span data-ttu-id="a1ef6-122"><a href="hololens-hardware-details.md">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="a1ef6-122"><a href="hololens-hardware-details.md">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="a1ef6-123"><a href="immersive-headset-hardware-details.md">沉浸式耳机</a></span><span class="sxs-lookup"><span data-stu-id="a1ef6-123"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="a1ef6-124">共享 250 MR:HoloLens 和沉浸式耳机</span><span class="sxs-lookup"><span data-stu-id="a1ef6-124">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="a1ef6-125">✔️</span><span class="sxs-lookup"><span data-stu-id="a1ef6-125">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="a1ef6-126">✔️</span><span class="sxs-lookup"><span data-stu-id="a1ef6-126">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="a1ef6-127">开始之前</span><span class="sxs-lookup"><span data-stu-id="a1ef6-127">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="a1ef6-128">先决条件</span><span class="sxs-lookup"><span data-stu-id="a1ef6-128">Prerequisites</span></span>

* <span data-ttu-id="a1ef6-129">使用 Windows 10 电脑[必要开发工具](install-the-tools.md)并[配置为支持 Windows Mixed Reality 沉浸式头戴式](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-129">A Windows 10 PC with the [necessary development tools](install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="a1ef6-130">适用于您的 PC 一个 Xbox 控制器。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-130">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="a1ef6-131">至少一个 HoloLens 设备和一个沉浸式头戴式耳机。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-131">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="a1ef6-132">这允许发现的 UDP 广播网络。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-132">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="a1ef6-133">项目文件</span><span class="sxs-lookup"><span data-stu-id="a1ef6-133">Project files</span></span>

* <span data-ttu-id="a1ef6-134">下载[文件](https://github.com/Microsoft/MixedReality250/archive/master.zip)所需的项目。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-134">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="a1ef6-135">将文件解压缩到易记的位置。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-135">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="a1ef6-136">此项目需要[Windows Mixed Reality 支持建议的版本的 Unity](install-the-tools.md)。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-136">This project requires the [a recommended version of Unity with Windows Mixed Reality support](install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="a1ef6-137">如果你想要查看完成的源代码下载前，它具有[可在 GitHub 上](https://github.com/Microsoft/MixedReality250)。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-137">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="a1ef6-138">第 1 章-Holo 世界</span><span class="sxs-lookup"><span data-stu-id="a1ef6-138">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="a1ef6-139">目标</span><span class="sxs-lookup"><span data-stu-id="a1ef6-139">Objectives</span></span>

<span data-ttu-id="a1ef6-140">请确保在开发环境已准备好使用一个简单的项目。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-140">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="a1ef6-141">我们将生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-141">What we will build</span></span>

<span data-ttu-id="a1ef6-142">HoloLens 或 Windows Mixed Reality 沉浸式头戴式显示一张全息图应用程序。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-142">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="a1ef6-143">步骤</span><span class="sxs-lookup"><span data-stu-id="a1ef6-143">Steps</span></span>
* <span data-ttu-id="a1ef6-144">打开 Unity。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-144">Open Unity.</span></span>
    * <span data-ttu-id="a1ef6-145">选择**打开**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-145">Select **Open**.</span></span>
    * <span data-ttu-id="a1ef6-146">导航到解压缩项目文件。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-146">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="a1ef6-147">单击“选择文件夹”。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-147">Click **Select Folder**.</span></span>
    * <span data-ttu-id="a1ef6-148">*将需要一段也用于 Unity 处理第一次的项目。*</span><span class="sxs-lookup"><span data-stu-id="a1ef6-148">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="a1ef6-149">检查在 Unity 中启用混合现实。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-149">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="a1ef6-150">打开生成设置对话框 (**控制 + Shift + B**或**文件 > 生成设置...**).</span><span class="sxs-lookup"><span data-stu-id="a1ef6-150">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="a1ef6-151">选择**通用 Windows 平台**然后单击**交换机平台**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-151">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="a1ef6-152">选择**编辑 > 播放器设置**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-152">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="a1ef6-153">在中**Inspector**上的右侧面板中，展开**XR 设置**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-153">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="a1ef6-154">检查**受支持的虚拟现实**框。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-154">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="a1ef6-155">*Windows Mixed Reality 应虚拟现实 SDK。*</span><span class="sxs-lookup"><span data-stu-id="a1ef6-155">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="a1ef6-156">创建一个场景。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-156">Create a scene.</span></span>
    * <span data-ttu-id="a1ef6-157">在中**层次结构**右键单击**Main Camera**选择**删除**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-157">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="a1ef6-158">从**HoloToolkit > 输入 > 预设**拖动**MixedRealityCameraParent**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-158">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="a1ef6-159">向场景添加全息</span><span class="sxs-lookup"><span data-stu-id="a1ef6-159">Add Holograms to the scene</span></span>
    * <span data-ttu-id="a1ef6-160">从**AppPrefabs**拖动**Skybox**到**场景视图**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-160">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="a1ef6-161">从**AppPrefabs**拖动**经理**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-161">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="a1ef6-162">从**AppPrefabs**拖动**岛**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-162">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="a1ef6-163">保存并生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-163">Save And build</span></span>
    * <span data-ttu-id="a1ef6-164">保存 (任一**控制 + S**或**文件 > 保存场景**)</span><span class="sxs-lookup"><span data-stu-id="a1ef6-164">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="a1ef6-165">由于这是新的场景，你将需要其命名。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-165">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="a1ef6-166">名称并不重要，但我们使用 SharedMixedReality。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-166">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="a1ef6-167">将导出到 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="a1ef6-167">Export To Visual Studio</span></span>
    * <span data-ttu-id="a1ef6-168">打开生成菜单 (**控制 + Shift + B**或**文件 > 生成设置**)</span><span class="sxs-lookup"><span data-stu-id="a1ef6-168">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="a1ef6-169">单击**添加打开的场景。**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-169">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="a1ef6-170">检查**UnityC#项目**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-170">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="a1ef6-171">单击“生成” 。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-171">Click **Build**.</span></span>
    * <span data-ttu-id="a1ef6-172">在文件资源管理器窗口中显示，创建名为的新文件夹**应用**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-172">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="a1ef6-173">单击一下**应用**文件夹。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-173">Single click the **App** folder.</span></span>
    * <span data-ttu-id="a1ef6-174">按**选择文件夹。**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-174">Press **Select Folder.**</span></span>
    * <span data-ttu-id="a1ef6-175">**等待生成完成**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-175">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="a1ef6-176">在文件资源管理器窗口中显示，导航到**应用**文件夹。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-176">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="a1ef6-177">双击**SharedMixedReality.sln**以启动 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="a1ef6-177">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="a1ef6-178">从 Visual Studio 生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-178">Build From Visual Studio</span></span>
    * <span data-ttu-id="a1ef6-179">使用顶部的工具栏更改到目标**发行**并**x86**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-179">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="a1ef6-180">单击箭头旁边**本地计算机**，然后选择**设备**将部署到 HoloLens</span><span class="sxs-lookup"><span data-stu-id="a1ef6-180">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="a1ef6-181">单击箭头旁边**设备**，然后选择**本地计算机**部署混合的现实耳机。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-181">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="a1ef6-182">单击**调试-> 启动但不调试**或**控制 + F5**启动应用程序。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-182">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="a1ef6-183">深入探讨代码</span><span class="sxs-lookup"><span data-stu-id="a1ef6-183">Digging into the code</span></span>

<span data-ttu-id="a1ef6-184">在项目面板中，导航到**Assets\HoloToolkit\Input\Scripts\Utilities**然后双击**MixedRealityCameraManager.cs**以将其打开。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-184">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="a1ef6-185">**概述：** MixedRealityCameraManager.cs 是一个简单的脚本，可调整基于设备的质量级别和背景设置。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-185">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="a1ef6-186">是 HolographicSettings.IsDisplayOpaque，允许脚本以检测设备是否处于 HoloLens （IsDisplayOpaque 返回 false） 或沉浸式头戴式 （IsDisplayOpaque 返回 true）。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-186">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="a1ef6-187">享受您的进度</span><span class="sxs-lookup"><span data-stu-id="a1ef6-187">Enjoy your progress</span></span>

<span data-ttu-id="a1ef6-188">此时应用程序只需将呈现一张全息图。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-188">At this point the application will just render a hologram.</span></span> <span data-ttu-id="a1ef6-189">我们将在稍后添加到全息图交互。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-189">We will add interaction to the hologram later.</span></span> <span data-ttu-id="a1ef6-190">这两种设备将呈现全息图相同。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-190">Both devices will render the hologram the same.</span></span> <span data-ttu-id="a1ef6-191">沉浸式头戴式还会呈现蓝色天空和云背景。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-191">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="a1ef6-192">第 2 章-交互</span><span class="sxs-lookup"><span data-stu-id="a1ef6-192">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="a1ef6-193">目标</span><span class="sxs-lookup"><span data-stu-id="a1ef6-193">Objectives</span></span>

<span data-ttu-id="a1ef6-194">演示如何处理 Windows Mixed Reality 应用程序的输入。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-194">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="a1ef6-195">我们将生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-195">What we will build</span></span>

<span data-ttu-id="a1ef6-196">第 1 章提供的应用程序上构建，我们将添加功能，可允许用户选取全息图，并将其放置在 HoloLens 现实世界图面上或在沉浸式头戴式中对虚拟表。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-196">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="a1ef6-197">**输入刷新程序：** 选择手势是在 HoloLens**敲击**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-197">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="a1ef6-198">在沉浸式耳机，我们将使用**A** Xbox 控制器上的按钮。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-198">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="a1ef6-199">有关详细信息输入[从这里开始](gestures.md)。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-199">For more information on input [start here](gestures.md).</span></span>

### <a name="steps"></a><span data-ttu-id="a1ef6-200">步骤</span><span class="sxs-lookup"><span data-stu-id="a1ef6-200">Steps</span></span>
* <span data-ttu-id="a1ef6-201">添加输入管理器</span><span class="sxs-lookup"><span data-stu-id="a1ef6-201">Add Input manager</span></span>
    * <span data-ttu-id="a1ef6-202">从**HoloToolkit > 输入 > 预设**拖动**InputManager**到**层次结构**的小孩**经理**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-202">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="a1ef6-203">从**HoloToolkit > 输入 > 预设 > 游标**拖动**光标**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-203">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="a1ef6-204">添加空间映射</span><span class="sxs-lookup"><span data-stu-id="a1ef6-204">Add Spatial Mapping</span></span>
    * <span data-ttu-id="a1ef6-205">从**HoloToolkit > SpatialMapping > 预设**拖动**SpatialMapping**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-205">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="a1ef6-206">添加虚拟 Playspace</span><span class="sxs-lookup"><span data-stu-id="a1ef6-206">Add Virtual Playspace</span></span>
    * <span data-ttu-id="a1ef6-207">在中**层次结构**展开**MixedRealityCameraParent**选择**边界**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-207">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="a1ef6-208">在中**Inspector**面板中选中复选框以启用**边界**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-208">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="a1ef6-209">从**AppPrefabs**拖动**VRRoom**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-209">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="a1ef6-210">添加 WorldAnchorManager</span><span class="sxs-lookup"><span data-stu-id="a1ef6-210">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="a1ef6-211">在中**层次结构**，选择**经理**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-211">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="a1ef6-212">在中**Inspector**，单击**添加组件**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-212">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="a1ef6-213">类型**世界定位点管理器**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-213">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="a1ef6-214">选择**世界定位点管理器**以将其添加。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-214">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="a1ef6-215">将 TapToPlace 添加到岛</span><span class="sxs-lookup"><span data-stu-id="a1ef6-215">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="a1ef6-216">在中**层次结构**，展开**岛**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-216">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="a1ef6-217">选择**MixedRealityLand**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-217">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="a1ef6-218">在中**Inspector**，单击**添加组件**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-218">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="a1ef6-219">类型**点击位置**并将其选中。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-219">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="a1ef6-220">检查**父置于点击**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-220">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="a1ef6-221">设置**放置偏移量**到 **（0，0.1，0）**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-221">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="a1ef6-222">保存并像以前那样生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-222">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="a1ef6-223">深入探讨代码</span><span class="sxs-lookup"><span data-stu-id="a1ef6-223">Digging into the code</span></span>

<span data-ttu-id="a1ef6-224">**Script 1 - GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-224">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="a1ef6-225">在项目面板中导航到**Assets\HoloToolkit\Input\Scripts\InputSources**然后双击**GamepadInput.cs**以将其打开。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-225">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="a1ef6-226">从项目面板中的相同路径，双击**InteractionSourceInputSource.cs**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-226">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="a1ef6-227">请注意，这两个脚本具有一个公共基类，BaseInputSource。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-227">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="a1ef6-228">BaseInputSource 保留对 InputManager，允许触发事件的脚本的引用。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-228">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="a1ef6-229">在这种情况下，InputClicked 事件是相关的。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-229">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="a1ef6-230">这将是一定要记住，当我们获取到脚本 2，TapToPlace。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-230">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="a1ef6-231">对于 GamePadInput，我们轮询按下，在控制器上的一个按钮，然后我们引发 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-231">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="a1ef6-232">对于 InteractionSourceInputSource，我们引发响应 TappedEvent InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-232">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="a1ef6-233">**脚本 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-233">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="a1ef6-234">在项目面板中导航到**Assets\HoloToolkit\SpatialMapping\Scripts**然后双击**TapToPlace.cs**以将其打开。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-234">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="a1ef6-235">许多开发人员想要实现创建全息版的应用程序时的第一个操作移动全息手势输入。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-235">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="a1ef6-236">在这种情况下，我们已 endeavored 进行全面注释此脚本。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-236">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="a1ef6-237">值得强调本教程中的一些事项。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-237">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="a1ef6-238">首先，请注意 TapToPlace 实现 IInputClickHandler。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-238">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="a1ef6-239">IInputClickHandler 公开函数，用于处理由 GamePadInput.cs 或 InteractionSourceInputSource.cs 引发的 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-239">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="a1ef6-240">OnInputClicked 时 BaseInputSource 检测单击具有 TapToPlace 对象处于焦点时调用。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-240">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="a1ef6-241">是 airtapping 上 HoloLens 或 Xbox 控制器上按一个按钮将触发该事件。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-241">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="a1ef6-242">第二个是执行更新，请参阅是否图面正在调查以便我们可以将游戏对象放在表面，类似于表中的代码。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-242">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="a1ef6-243">因此沉浸式头戴式没有概念实际应用层协议，该对象表示表顶部 (Vroom > TableThingy > 多维数据集) 已被标记为 SpatialMapping 物理层，因此在更新中强制转换的射线将与虚拟表顶部发生冲突。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-243">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="a1ef6-244">享受您的进度</span><span class="sxs-lookup"><span data-stu-id="a1ef6-244">Enjoy your progress</span></span>

<span data-ttu-id="a1ef6-245">这一次可以选择岛以将其移动。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-245">This time you can select the island to move it.</span></span> <span data-ttu-id="a1ef6-246">HoloLens 上可以将岛移到实际的图面。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-246">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="a1ef6-247">在沉浸式头戴式可以将岛移到我们添加的虚拟表。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-247">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="a1ef6-248">第 3 章 — 共享</span><span class="sxs-lookup"><span data-stu-id="a1ef6-248">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="a1ef6-249">目标</span><span class="sxs-lookup"><span data-stu-id="a1ef6-249">Objectives</span></span>

<span data-ttu-id="a1ef6-250">确保已正确配置的网络，并且详细介绍如何在设备之间共享空间的定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-250">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="a1ef6-251">我们将生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-251">What we will build</span></span>

<span data-ttu-id="a1ef6-252">我们会将我们的项目转换到多玩家项目。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-252">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="a1ef6-253">我们会将 UI 和逻辑添加到主机或联接会话。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-253">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="a1ef6-254">HoloLens 用户将看到每个其他云会话中通过头、 和沉浸式头戴式用户有接近定位点所在的云。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-254">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="a1ef6-255">在沉浸式耳机的用户将看到相对于场景的原点的 HoloLens 用户。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-255">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="a1ef6-256">HoloLens 用户将看到在同一位置岛的全息图。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-256">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="a1ef6-257">请注意沉浸式耳机中的用户将不会在岛上这一章，但将行为非常相似到 HoloLens，岛的鸟密切关注视图至关重要。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-257">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="a1ef6-258">步骤</span><span class="sxs-lookup"><span data-stu-id="a1ef6-258">Steps</span></span>
* <span data-ttu-id="a1ef6-259">删除岛和 VRRoom</span><span class="sxs-lookup"><span data-stu-id="a1ef6-259">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="a1ef6-260">在中**层次结构**右键单击**岛**选择**删除**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-260">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="a1ef6-261">在中**层次结构**右键单击**VRRoom**选择**删除**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-261">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="a1ef6-262">添加 Usland</span><span class="sxs-lookup"><span data-stu-id="a1ef6-262">Add Usland</span></span>
    * <span data-ttu-id="a1ef6-263">从**AppPrefabs**拖动**Usland**到**层次结构**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-263">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="a1ef6-264">从**AppPrefabs**拖到下面每一**层次结构**:</span><span class="sxs-lookup"><span data-stu-id="a1ef6-264">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="a1ef6-265">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-265">**UNETSharingStage**</span></span>
    * <span data-ttu-id="a1ef6-266">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-266">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="a1ef6-267">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-267">**UIContainer**</span></span>
    * <span data-ttu-id="a1ef6-268">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-268">**DebugPanelButton**</span></span>
* <span data-ttu-id="a1ef6-269">保存并像以前那样生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-269">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="a1ef6-270">深入探讨代码</span><span class="sxs-lookup"><span data-stu-id="a1ef6-270">Digging into the code</span></span>

<span data-ttu-id="a1ef6-271">在项目面板中，导航到**Assets\AppPrefabs\Support\SharingWithUnet\Scripts** ，并双击**UnetAnchorManager.cs**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-271">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="a1ef6-272">一个 HoloLens 与另一个 HoloLens 共享跟踪信息，以便这两种设备可以共享相同的空间的功能即将达到神奇。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-272">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="a1ef6-273">混合现实的强大功能处于活动状态时两个或更多的人可以使用相同的数字数据进行协作。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-273">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="a1ef6-274">需要指出此脚本中的一些事项：</span><span class="sxs-lookup"><span data-stu-id="a1ef6-274">A few things to point out in this script:</span></span>

<span data-ttu-id="a1ef6-275">在开始函数中，请注意，检查是否有**IsDisplayOpaque**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-275">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="a1ef6-276">在这种情况下，我们假设建立定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-276">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="a1ef6-277">这是因为沉浸式耳机不会公开一种方法来导入或导出的定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-277">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="a1ef6-278">如果我们在 HoloLens 上运行，但是，此脚本实现设备之间共享的定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-278">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="a1ef6-279">启动会话的设备将创建用于导出的定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-279">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="a1ef6-280">加入会话时的设备将从设备启动会话的请求定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-280">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="a1ef6-281">**导出：**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-281">**Exporting:**</span></span>

<span data-ttu-id="a1ef6-282">当用户创建一个会话时，NetworkDiscoveryWithAnchors 将调用 UNETAnchorManagers CreateAnchor 函数。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-282">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="a1ef6-283">让我们按照 CreateAnchor 流。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-283">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="a1ef6-284">我们首先执行一些保养工作，清除任何数据，我们有可能收集的上一个定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-284">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="a1ef6-285">然后我们会检查是否有要加载的缓存的密钥。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-285">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="a1ef6-286">定位点数据往往介于 5 到 20 个 MB，以便重复使用缓存的定位点可以在保存的数据，我们需要通过网络进行传输的量。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-286">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="a1ef6-287">我们将看到此工作方式有点更高版本。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-287">We'll see how this works a bit later.</span></span> <span data-ttu-id="a1ef6-288">即使我们要重新使用定位点，我们需要获取数据准备新的客户端加入的情况下不具有的定位点定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-288">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="a1ef6-289">谈到准备定位点数据，WorldAnchorTransferBatch 类公开的功能来准备要定位数据发送到另一台设备或应用程序和功能，若要导入的定位点数据。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-289">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="a1ef6-290">由于我们是在导出路径上，我们会将我们的定位点添加到 WorldAnchorTransferBatch 并调用 ExportAsync 函数。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-290">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="a1ef6-291">为生成导出的数据，ExportAsync 然后将调用 WriteBuffer 回调。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-291">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="a1ef6-292">导出的所有数据后将调用 ExportComplete。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-292">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="a1ef6-293">WriteBuffer 中我们将数据块添加到我们将继续保留用于导出的列表。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-293">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="a1ef6-294">ExportComplete 中我们将列表转换为数组。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-294">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="a1ef6-295">AnchorName 变量也设置，这将触发其他设备以请求定位点，如果他们没有它。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-295">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="a1ef6-296">在某些情况下，定位点不会导出或将创建极少的数据，我们将重试。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-296">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="a1ef6-297">此处我们只需 CreateAnchor 再次调用。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-297">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="a1ef6-298">导出路径中的最后一个函数是 AnchorFoundRemotely。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-298">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="a1ef6-299">当另一台设备发现了定位点时，该设备将告诉主机和主机将使用的作为定位点是"良好定位点"的信号，并可以缓存。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-299">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="a1ef6-300">**导入：**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-300">**Importing:**</span></span>

<span data-ttu-id="a1ef6-301">当 HoloLens 加入会话时，它需要导入定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-301">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="a1ef6-302">在 UNETAnchorManager 的更新函数中，AnchorName 被轮询一次。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-302">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="a1ef6-303">定位点名称更改时，导入过程开始。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-303">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="a1ef6-304">首先，我们尝试从本地的定位点存储加载具有指定名称的定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-304">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="a1ef6-305">如果我们已经有了它，我们可以使用它而无需再次下载数据。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-305">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="a1ef6-306">如果我们没有它，然后我们调用 WaitForAnchor 将启动下载。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-306">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="a1ef6-307">完成下载后，调用 NetworkTransmitter_dataReadyEvent。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-307">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="a1ef6-308">这将指示更新循环以使用下载的数据调用 ImportAsync。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-308">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="a1ef6-309">导入过程完成后，ImportAsync 将调用 ImportComplete。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-309">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="a1ef6-310">如果导入成功，定位点将保存在本地播放机应用商店。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-310">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="a1ef6-311">PlayerController.cs 实际上可以调用 AnchorFoundRemotely 以让主机知道已建立良好的定位点。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-311">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="a1ef6-312">享受您的进度</span><span class="sxs-lookup"><span data-stu-id="a1ef6-312">Enjoy your progress</span></span>

<span data-ttu-id="a1ef6-313">这一次用户与 HoloLens 将承载会话使用**启动会话**在 UI 中的按钮。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-313">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="a1ef6-314">其他用户，同时在 HoloLens 或沉浸式头戴式耳机，将选择该会话，然后选择**加入会话**在 UI 中的按钮。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-314">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="a1ef6-315">如果有多个用户与 HoloLens 设备，他们将对着头看有红色的云。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-315">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="a1ef6-316">此外将每个沉浸式头戴式耳机，蓝色云朵不过蓝色云将不是上面耳机，因为耳机不尝试查找与 HoloLens 设备相同的世界坐标空间。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-316">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="a1ef6-317">此项目中的点是一个包含共享的应用程序;它不多，并可作为比较基准。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-317">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="a1ef6-318">在下一步的章节中，我们将开始生成的人们能够享受的体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-318">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="a1ef6-319">若要获取进一步上共享的体验设计指南，请转到此处。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-319">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="a1ef6-320">第 4 章-浸入式和 teleporting</span><span class="sxs-lookup"><span data-stu-id="a1ef6-320">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="a1ef6-321">目标</span><span class="sxs-lookup"><span data-stu-id="a1ef6-321">Objectives</span></span>

<span data-ttu-id="a1ef6-322">在面向到每种类型的混合的现实设备的体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-322">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="a1ef6-323">我们将生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-323">What we will build</span></span>

<span data-ttu-id="a1ef6-324">我们将更新应用程序将在沉浸式视图岛上的沉浸式头戴式用户。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-324">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="a1ef6-325">HoloLens 用户将仍然可以岛的鸟瞰视图。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-325">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="a1ef6-326">每个设备类型的用户可以看到其他用户，世界中的显示方式。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-326">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="a1ef6-327">例如，沉浸式头戴式用户可以看到岛上的其他路径上的其他虚拟形象和 HoloLens 用户看作上面岛的巨大云。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-327">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="a1ef6-328">如果 HoloLens 用户正在查看岛，沉浸式头戴式用户也会看到 HoloLens 用户视线移动射线的光标。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-328">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="a1ef6-329">HoloLens 用户将在岛来表示每个沉浸式头戴式用户上看到头像。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-329">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="a1ef6-330">**沉浸式设备的更新的输入：**</span><span class="sxs-lookup"><span data-stu-id="a1ef6-330">**Updated Input for the Immersive device:**</span></span>
* <span data-ttu-id="a1ef6-331">Xbox 控制器上的左侧缓冲器和右缓冲器按钮旋转播放机</span><span class="sxs-lookup"><span data-stu-id="a1ef6-331">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="a1ef6-332">保存 Xbox 控制器上的 Y 按钮将启用[teleport](navigating-the-windows-mixed-reality-home.md#getting-around-your-home)游标。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-332">Holding the Y button on the Xbox controller will enable a [teleport](navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="a1ef6-333">如果释放 Y 按钮时，游标将有一个旋转箭头指示符，将为 teleported 到游标的位置。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-333">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="a1ef6-334">步骤</span><span class="sxs-lookup"><span data-stu-id="a1ef6-334">Steps</span></span>
* <span data-ttu-id="a1ef6-335">添加到 MixedRealityCameraParent MixedRealityTeleport</span><span class="sxs-lookup"><span data-stu-id="a1ef6-335">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="a1ef6-336">在中**层次结构**，选择**Usland**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-336">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="a1ef6-337">在中**Inspector**，启用**级别控制**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-337">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="a1ef6-338">在中**层次结构**，选择**MixedRealityCameraParent**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-338">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="a1ef6-339">在中**Inspector**，单击**添加组件**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-339">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="a1ef6-340">类型**混合现实 Teleport**并将其选中。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-340">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="a1ef6-341">深入探讨代码</span><span class="sxs-lookup"><span data-stu-id="a1ef6-341">Digging into the code</span></span>

<span data-ttu-id="a1ef6-342">沉浸式头戴式用户将已接入到他们的 Pc 电缆，但我们岛较大的电缆是长时间。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-342">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="a1ef6-343">若要补偿，我们需要移动独立于用户的运动相机的功能。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-343">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="a1ef6-344">请参阅[舒适页](comfort.md)设计混合的现实应用程序 （特别是自运动和 locomotion） 有关详细信息。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-344">Please see the [comfort page](comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="a1ef6-345">为了说明此过程将需要定义两个术语。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-345">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="a1ef6-346">首先，**运输车**将从用户独立移动相机的对象。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-346">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="a1ef6-347">一个子游戏对象**运输车**将为**主照相机**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-347">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="a1ef6-348">主照相机被附加到用户的头。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-348">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="a1ef6-349">在项目面板中，导航到**Assets\AppPrefabs\Support\Scripts\GameLogic** ，并双击**MixedRealityTeleport.cs**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-349">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="a1ef6-350">MixedRealityTeleport 具有两个作业。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-350">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="a1ef6-351">首先，它可以处理使用缓冲器旋转。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-351">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="a1ef6-352">在更新函数中我们轮询 LeftBumper 和 RightBumper ButtonUp。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-352">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="a1ef6-353">GetButtonUp 仅返回 true 之后又被向下按钮已启动第一个框架上。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-353">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="a1ef6-354">如果未引发任一按钮，我们知道用户需要进行旋转。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-354">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="a1ef6-355">我们旋转时我们执行淡入淡出和淡入使用一个简单的脚本名为 fade 控件。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-355">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="a1ef6-356">我们这样做可以防止用户看到的不自然的位移，这可能导致不适。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-356">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="a1ef6-357">淡入淡出和签出的效果是相当简单。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-357">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="a1ef6-358">我们有挂起的前面黑色四**主照相机**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-358">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="a1ef6-359">淡我们转换从 0 到 1 的 alpha 值。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-359">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="a1ef6-360">这将逐渐导致四来呈现并会掩盖其背后提供支持的任何内容的黑色像素。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-360">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="a1ef6-361">当返回淡出我们过渡的 alpha 值为零。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-361">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="a1ef6-362">当我们计算旋转时，请注意，我们要轮替我们**运输车**但计算绕旋转**主照相机**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-362">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="a1ef6-363">这是重要，因为较远**主照相机**离开 0,0,0，是不太准确绕运输车旋转将成为从用户的角度。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-363">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="a1ef6-364">事实上，如果不旋转照相机的位置附近，用户将移动上一段弧线，围绕**运输车**而不是旋转。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-364">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="a1ef6-365">MixedRealityTeleport 的第二个作业将处理移动**运输车**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-365">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="a1ef6-366">这是在 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-366">This is done in SetWorldPosition.</span></span> <span data-ttu-id="a1ef6-367">SetWorldPosition 采用所需的世界位置，用户希望 percieve 它们占据的位置。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-367">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="a1ef6-368">我们需要将我们**运输车**减去的本地位置的该位置**主照相机**，因为该偏移量就会添加每个帧。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-368">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="a1ef6-369">第二个脚本调用 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-369">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="a1ef6-370">让我们看一下该脚本。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-370">Let's look at that script.</span></span> <span data-ttu-id="a1ef6-371">在项目面板中，导航到**Assets\AppPrefabs\Support\Scripts\GameLogic** ，并双击**TeleportScript.cs**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-371">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="a1ef6-372">此脚本是比 MixedRealityTeleport 有点复杂。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-372">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="a1ef6-373">正在检查 Xbox 控制器上的 Y 按钮，以按下的脚本。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-373">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="a1ef6-374">持有该按钮时光标呈现 teleport 下和脚本将从用户的视线移动位置 ray 强制转换。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-374">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="a1ef6-375">如果该射线与增加或减少正的表面上有冲突，指向在图面将被视为到 teleport，良好的图面，将启用对 teleport 游标动画。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-375">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="a1ef6-376">如果该射线不与图面，增加或减少指针冲突，则将禁用对游标的动画。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-376">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="a1ef6-377">时发布的 Y 按钮和计算的射线的点是有效的位置，则脚本将调用 SetWorldPosition 与射线相交的位置。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-377">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="a1ef6-378">享受您的进度</span><span class="sxs-lookup"><span data-stu-id="a1ef6-378">Enjoy your progress</span></span>

<span data-ttu-id="a1ef6-379">这一次你需要找到一位朋友。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-379">This time you'll need to find a friend.</span></span>

<span data-ttu-id="a1ef6-380">再次重申，具有 HoloLens 的用户将承载会话。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-380">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="a1ef6-381">其他用户将加入会话。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-381">Other users will join the session.</span></span> <span data-ttu-id="a1ef6-382">应用程序会将前三个用户从一个岛上的三个路径上沉浸式头戴式加入。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-382">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="a1ef6-383">随意浏览在本部分中岛。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-383">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="a1ef6-384">需要注意的详细信息：</span><span class="sxs-lookup"><span data-stu-id="a1ef6-384">Details to notice:</span></span>
1. <span data-ttu-id="a1ef6-385">您可以看到人脸在云中，从而可帮助 immersed 的用户可以查看 HoloLens 用户正在查找的方向。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-385">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="a1ef6-386">头像岛上的具有 necks 旋转。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-386">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="a1ef6-387">它们不会按照用户的作用是 （我们没有该信息） 的真实现实，但它具有很好的体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-387">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="a1ef6-388">如果 HoloLens 用户正在查看岛，immersed 的用户可以看到其光标。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-388">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="a1ef6-389">表示 HoloLens 用户的云转换阴影。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-389">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="a1ef6-390">第 5 章-最终方法</span><span class="sxs-lookup"><span data-stu-id="a1ef6-390">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="a1ef6-391">目标</span><span class="sxs-lookup"><span data-stu-id="a1ef6-391">Objectives</span></span>

<span data-ttu-id="a1ef6-392">创建两个设备类型之间的协作交互式体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-392">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="a1ef6-393">我们将生成</span><span class="sxs-lookup"><span data-stu-id="a1ef6-393">What we will build</span></span>

<span data-ttu-id="a1ef6-394">当沉浸式头戴式具有的用户在岛上获取附近填数游戏的基础上第 4 章，HoloLens 用户将获得带给出测验题的线索的工具提示。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-394">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="a1ef6-395">一旦所有沉浸式头戴式用户火箭房间中获取过去的其填数游戏和到"准备板"上，将启动火箭。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-395">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="a1ef6-396">步骤</span><span class="sxs-lookup"><span data-stu-id="a1ef6-396">Steps</span></span>
* <span data-ttu-id="a1ef6-397">在中**层次结构**，选择**Usland**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-397">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="a1ef6-398">在中**Inspector**，在**级别控制**，检查**启用协作**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-398">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="a1ef6-399">深入探讨代码</span><span class="sxs-lookup"><span data-stu-id="a1ef6-399">Digging into the code</span></span>

<span data-ttu-id="a1ef6-400">现在让我们看一下 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-400">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="a1ef6-401">此脚本是游戏逻辑核心，并维护游戏状态。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-401">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="a1ef6-402">由于这是使用 UNET 的多玩家游戏我们需要了解的数据流动方式，至少也足够修改本教程。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-402">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="a1ef6-403">UNET 的更完整概述，请参阅 Unity 的文档。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-403">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="a1ef6-404">在项目面板中，导航到**Assets\AppPrefabs\Support\Scripts\GameLogic** ，并双击**LevelControl.cs**。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-404">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="a1ef6-405">让我们了解一下如何沉浸式头戴式指示它们可供火箭启动。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-405">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="a1ef6-406">列表中的对应于岛上的三个路径的布尔设置三个布尔的其中一个可传达火箭启动准备情况。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-406">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="a1ef6-407">当分配给路径的用户基础火箭房间内的棕色板上时，将设置路径的布尔值。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-407">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="a1ef6-408">好了，现在我们来详细信息。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-408">Okay, now to the details.</span></span>

<span data-ttu-id="a1ef6-409">我们会在 update （） 函数中。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-409">We will start in the Update() function.</span></span> <span data-ttu-id="a1ef6-410">您将注意有备' 函数。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-410">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="a1ef6-411">我们用它在开发过程中来测试火箭启动和重置序列。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-411">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="a1ef6-412">它无法在多用户体验。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-412">It won't work in the multi user experience.</span></span> <span data-ttu-id="a1ef6-413">希望按时间消化理解以下信息可以使其工作。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-413">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="a1ef6-414">请参阅是否我们应耍了花招，我们检查后，我们检查以查看是否沉浸本地播放机。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-414">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="a1ef6-415">我们想要专注于我们发现我们所处的目标。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-415">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="a1ef6-416">在 if （沉浸） 检查，没有调用来隐藏 CheckGoal **EnableCollaboration** bool。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-416">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="a1ef6-417">这对应于完成这一章的步骤同时选中该复选框。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-417">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="a1ef6-418">内部 EnableCollaboration 我们可以看到对 CheckGoal() 的调用。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-418">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="a1ef6-419">CheckGoal 执行某些数学运算来确定我们是否增加或减少现有板上。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-419">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="a1ef6-420">当我们，我们 Debug.Log"已到达目标"，然后我们调用 SendAtGoalMessage()。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-420">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="a1ef6-421">在 SendAtGoalMessage 我们调用 playerController.SendAtGoal。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-421">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="a1ef6-422">为你节省一些时间，下面是代码：</span><span class="sxs-lookup"><span data-stu-id="a1ef6-422">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
       {
           levelState.SetGoalIndex(GoalIndex);
       }
```

```cs
public void SendAtGoal(int GoalIndex)
       {
           if (isLocalPlayer)
           {
               Debug.Log("sending at goal " + GoalIndex);
               CmdSendAtGoal(GoalIndex);
           }
       }
```

<span data-ttu-id="a1ef6-423">请注意 SendAtGoalMessage 调用 CmdSendAtGoal，哪些调用 levelState.SetGoalIndex，LevelControl.cs 已恢复。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-423">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="a1ef6-424">乍一看这似乎有点奇怪。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-424">At first glance this seems strange.</span></span> <span data-ttu-id="a1ef6-425">为什么不只是调用 SetGoalIndex 而不是这很奇怪，player 控制器通过路由？</span><span class="sxs-lookup"><span data-stu-id="a1ef6-425">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="a1ef6-426">原因是我们符合到 UNET 用于使数据保持同步的数据模型。为防止作弊和抖动，UNET 要求每个对象都有权更改已同步的变量的用户。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-426">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="a1ef6-427">此外，主机 （启动会话的用户） 可以直接更改数据。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-427">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="a1ef6-428">用户不是主机，但具有颁发机构，需要将 command 发送到的主机，这将更改该变量。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-428">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="a1ef6-429">默认情况下主机具有颁发机构对所有对象，生成来表示用户的对象除外。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-429">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="a1ef6-430">在本例中此对象具有 playercontroller 脚本。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-430">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="a1ef6-431">一种方法来请求对象的颁发机构，然后进行更改，但我们选择利用这一事实，player 控制器已通过，player 控制器的自我颁发机构和路由命令。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-431">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="a1ef6-432">换句话说，我们发现我们自己在我们的目标时，播放机需要告诉主机，主机将告诉其他人。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-432">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="a1ef6-433">返回在 LevelControl.cs SetGoalIndex 看。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-433">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="a1ef6-434">此处我们将在 synclist (AtGoal) 中设置的值的值。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-434">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="a1ef6-435">请记住，我们是在主机的上下文中时执行此操作。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-435">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="a1ef6-436">类似于命令，RPC 是主机可以发出的内容将导致所有客户端运行一些代码。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-436">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="a1ef6-437">此处我们调用 RpcCheckAllGoals。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-437">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="a1ef6-438">每个客户端将逐个检查以查看是否设置所有三个 AtGoals，并且如果是这样，启动火箭。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-438">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="a1ef6-439">享受您的进度</span><span class="sxs-lookup"><span data-stu-id="a1ef6-439">Enjoy your progress</span></span>

<span data-ttu-id="a1ef6-440">基于上一章，我们将开始在与之前的会话。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-440">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="a1ef6-441">这次是对在其路径中，这个"门"沉浸式头戴式 get 中的用户作为工具提示将显示仅 HoloLens 用户可以看到。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-441">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="a1ef6-442">HoloLens 用户负责通信向在沉浸式头戴式用户此线索。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-442">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="a1ef6-443">火山中其相应棕色板上每个虚拟形象具有单步执行后，火箭将启动到空间。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-443">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="a1ef6-444">场景在 60 秒之后将重置以便可以再次执行它。</span><span class="sxs-lookup"><span data-stu-id="a1ef6-444">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="a1ef6-445">请参阅</span><span class="sxs-lookup"><span data-stu-id="a1ef6-445">See also</span></span>
* [<span data-ttu-id="a1ef6-446">MR 输入 213:运动控制器</span><span class="sxs-lookup"><span data-stu-id="a1ef6-446">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)
