---
title: 空间映射
description: 空间映射提供了在 HoloLens 环境中实际表面的详细表示。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射, HoloLens, 混合现实, 表面重建, 网格, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/24/2019
ms.locfileid: "63550489"
---
# <a name="spatial-mapping"></a><span data-ttu-id="ce9a5-104">空间映射</span><span class="sxs-lookup"><span data-stu-id="ce9a5-104">Spatial mapping</span></span>

<span data-ttu-id="ce9a5-105">空间映射提供了针对 HoloLens 环境中实际表面表面的详细表示, 使开发人员能够创建一个具有说服力混合的现实体验。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="ce9a5-106">通过将现实世界与虚拟世界合并, 应用程序可以使全息影像看起来非常真实。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="ce9a5-107">应用程序通过提供熟悉的实际行为和交互, 还可以更自然地与用户的预期保持一致。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="ce9a5-108">设备支持</span><span class="sxs-lookup"><span data-stu-id="ce9a5-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="ce9a5-109">功能</span><span class="sxs-lookup"><span data-stu-id="ce9a5-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="ce9a5-110"><a href="hololens-hardware-details.md">HoloLens（第一代）</a></span><span class="sxs-lookup"><span data-stu-id="ce9a5-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="ce9a5-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="ce9a5-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="ce9a5-112"><a href="immersive-headset-hardware-details.md">沉浸式头戴显示设备</a></span><span class="sxs-lookup"><span data-stu-id="ce9a5-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="ce9a5-113">空间映射</span><span class="sxs-lookup"><span data-stu-id="ce9a5-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="ce9a5-114">✔️</span><span class="sxs-lookup"><span data-stu-id="ce9a5-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="ce9a5-115">✔️</span><span class="sxs-lookup"><span data-stu-id="ce9a5-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="ce9a5-116">概念性概述</span><span class="sxs-lookup"><span data-stu-id="ce9a5-116">Conceptual overview</span></span>

<span data-ttu-id="ce9a5-117">![覆盖房间的网格面](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="ce9a5-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="ce9a5-118">*覆盖房间的空间映射网格示例*</span><span class="sxs-lookup"><span data-stu-id="ce9a5-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="ce9a5-119">用于空间映射的两个主要对象类型为 "空间图观察器" 和 "空间图面"。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="ce9a5-120">应用程序为空间图面观察器提供一个或多个边界卷, 以定义应用程序希望接收空间映射数据的空间区域。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="ce9a5-121">对于每个卷, 空间映射将为应用程序提供一组空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="ce9a5-122">这些卷可能是固定的 (在固定位置与现实世界相关), 也可能附加到 HoloLens (它们在环境中移动时不会进行旋转)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="ce9a5-123">每个空间图面都描述了小空间中的实际表面, 表示为附加到世界锁定的[空间坐标系统](coordinate-systems.md)的三角形网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="ce9a5-124">当 HoloLens 收集有关环境的新数据时, 如果对环境进行了更改, 空间图面将显示、消失和变化。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="ce9a5-125">常见使用方案</span><span class="sxs-lookup"><span data-stu-id="ce9a5-125">Common usage scenarios</span></span>

![常见空间映射使用方案的插图:放置、封闭、物理学和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="ce9a5-127">放置</span><span class="sxs-lookup"><span data-stu-id="ce9a5-127">Placement</span></span>

<span data-ttu-id="ce9a5-128">空间映射为应用程序提供了向用户提供自然和熟悉的交互形式的机会。比将电话向下移动电话的情况如何？</span><span class="sxs-lookup"><span data-stu-id="ce9a5-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="ce9a5-129">将全息图 (或更常见的空间位置选项) 的位置约束为在表面上提供从 3D (点到空间) 到 2D (点上点) 的自然映射。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="ce9a5-130">这会减少用户提供给应用程序所需的信息量, 进而使用户的交互速度更快、更简单且更精确。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="ce9a5-131">这种情况特别适用, 因为 "距离远离" 不是我们用于与其他人或计算机进行物理通信的内容。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="ce9a5-132">当我们使用手指点时, 我们指定的是一个方向, 而不是距离。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="ce9a5-133">此处需要注意的一个重要事项是, 当应用程序推断方向的距离 (例如, 沿用户的注视方向执行 raycast 以查找最接近的空间图面) 时, 这必须生成用户能够可靠预测的结果。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="ce9a5-134">否则, 用户将失去控制, 这很快就会变得沮丧。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="ce9a5-135">有助于实现此功能的一种方法是执行多个 raycasts, 而不是只执行一个。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="ce9a5-136">聚合结果应更平滑且更具可预测性, 不会影响暂时性的 "离群" 结果 (这可能是由于光线通过小孔而导致用户不知道的少量几何) 引起的。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="ce9a5-137">还可以在一段时间内执行聚合或平滑处理;例如, 可以限制每个用户与用户之间的距离变化的最大速度。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="ce9a5-138">只是限制最小值和最大距离值也很有帮助, 因此, 要移动的全息影像不会突然飞入到远处, 也不会发生故障。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="ce9a5-139">应用程序还可以使用图面的形状和方向来指导全息图放置。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="ce9a5-140">全息椅子不应穿透墙壁, 并应与地面齐平, 即使它略有变化。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="ce9a5-141">这种功能可能会依赖于使用物理学冲突而不只是 raycasts, 但会应用类似的问题。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="ce9a5-142">如果放置的全息图包含许多小多边形, 如椅子上的支线, 则将这些多边形的物理表示形式扩大到更宽和更平滑的位置, 使其更能在不适合.</span><span class="sxs-lookup"><span data-stu-id="ce9a5-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="ce9a5-143">在其极端情况下, 用户输入可以完全被简化, 空间表面可用于执行完全自动的全息影像放置。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="ce9a5-144">例如, 应用程序可能会在墙壁的某个位置放置一个全息片开关, 以便用户按下。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="ce9a5-145">与可预测性相同的注意事项也适用于:如果用户期望控制全息图放置, 但是应用程序并不总是在其预期位置放置全息影像 (如果光交换机出现在用户无法访问的某个位置), 那么这将是一项令人沮丧的体验。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="ce9a5-146">它实际上可能更糟地执行需要用户更正的自动放置, 而不是只要求用户始终执行放置;由于*预期*的自动放置成功, 手动更正就像是一种负担!</span><span class="sxs-lookup"><span data-stu-id="ce9a5-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="ce9a5-147">另请注意, 应用程序使用空间表面进行放置的能力很大程度上取决于应用程序的[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="ce9a5-148">如果尚未扫描图面, 则它不能用于放置。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="ce9a5-149">这是由应用程序为用户提供的, 因此, 他们可以帮助扫描新的表面或选择新的位置。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="ce9a5-150">在放置过程中, 对用户的视觉反馈非常重要。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="ce9a5-151">用户需要知道全息图与最接近的图面之间的关系, 并具有[接地效果](spatial-mapping.md#visualization)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="ce9a5-152">它们应了解为什么会限制其全息影像的移动 (例如, 由于与另一个附近表面发生冲突)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="ce9a5-153">如果它们无法在当前位置放置全息影像, 则视觉对象反馈应清楚地说明为什么不这样做。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="ce9a5-154">例如, 如果用户尝试将全息的沙发卡在墙壁上, 则墙后的沙发部分应 pulsate 为生气的颜色,。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="ce9a5-155">相反地, 如果应用程序在用户可以看到真实表面的位置找不到空间图面, 则应用程序应如此清晰。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="ce9a5-156">此区域中明显不会产生接地效果的情况。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="ce9a5-157">封闭</span><span class="sxs-lookup"><span data-stu-id="ce9a5-157">Occlusion</span></span>

<span data-ttu-id="ce9a5-158">空间映射图面的主要用途之一就是遮蔽全息影像。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="ce9a5-159">这一简单的行为对全息影像的明显影响非常大, 有助于创建 visceral 的意义, 真正与用户具有相同的物理空间。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="ce9a5-160">封闭还向用户提供信息;当真实的图面看不封闭像素全息图时, 这将向世界上该全息图的空间位置提供更多的视觉反馈。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="ce9a5-161">相反, 封闭也可以有用*隐藏*用户的信息;occluding 的后台影像可以以直观的方式减少视觉干扰。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="ce9a5-162">若要隐藏或显示全息图, 用户只需移动其头。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="ce9a5-163">封闭还可用于根据熟悉的物理交互, 为自然用户界面提供合理的预期。如果某个图面的封闭像素是一个全息图, 就是因为该表面是稳定的, 因此用户应该认为这种影像将与该表面发生*冲突*, 而不只是通过它。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="ce9a5-164">有时, 不需要封闭的全息影像。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="ce9a5-165">如果用户需要能够与全息图交互, 则他们需要能够看到它, 即使它位于实际的表面上。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="ce9a5-166">在这种情况下, 在封闭像素时 (例如, 通过降低亮度) 呈现此类全息图通常是有意义的。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="ce9a5-167">这样一来, 用户将能够以可视方式找到全息图, 但仍会注意到它位于某个地方。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="ce9a5-168">物理</span><span class="sxs-lookup"><span data-stu-id="ce9a5-168">Physics</span></span>

<span data-ttu-id="ce9a5-169">使用物理学模拟的另一种方法是使用空间映射来强化用户物理空间中*是否存在*全息影像。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="ce9a5-170">当我的全息橡胶球从真实上掷走, 弹跳在床上并消失后, 我很难相信它并不真正。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="ce9a5-171">物理学模拟还为应用程序提供了使用自然和熟悉的基于物理学的交互的机会。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="ce9a5-172">如果家具的响应方式与在楼层间滑动, 并具有适当的惯性和摩擦, 则用户可能会更容易地在地面上移动一张全息的家具。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="ce9a5-173">为了生成真实的物理行为, 你可能需要执行一些[网格处理](spatial-mapping.md#mesh-processing), 如填充孔、删除浮动 hallucinations 和平滑表面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="ce9a5-174">还需要考虑应用程序的[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)如何影响其物理模拟。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="ce9a5-175">首先, 缺少的图面不会与任何内容发生冲突;当橡胶球向下 corridor 并从已知世界结束时, 会发生什么情况呢？</span><span class="sxs-lookup"><span data-stu-id="ce9a5-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="ce9a5-176">其次, 您需要确定是否将在一段时间内继续对环境中的更改做出响应。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="ce9a5-177">在某些情况下, 你需要尽快做出响应;例如, 如果用户使用门和家具作为 barricades 中的可移动的 tempest, 则不会出现传入罗马字箭头的。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="ce9a5-178">但在其他情况下, 你可能想要忽略新的更新;如果狗决定坐在轨迹的中间, 则围绕地面的 racetrack 推动您的全息运动汽车就会突然不那么有趣。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="ce9a5-179">导航</span><span class="sxs-lookup"><span data-stu-id="ce9a5-179">Navigation</span></span>

<span data-ttu-id="ce9a5-180">应用程序可以使用空间映射数据来向全息人物 (或代理) 授予在真实情况上以相同方式浏览现实世界的能力。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="ce9a5-181">这可以通过将其限制为用户及其好友的一组自然、熟悉的行为来帮助强化是否存在全息字符。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="ce9a5-182">导航功能对于用户也很有用。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="ce9a5-183">在给定区域中生成导航地图后, 可以将其共享, 为不熟悉该位置的新用户提供全息说明。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="ce9a5-184">此映射可用于帮助保持行人的流量顺畅地流动, 或避免在危险位置 (如构造站点) 中发生意外。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="ce9a5-185">实现导航功能所涉及的关键技术挑战将是对不可图面 (人不对表格进行浏览!) 和正常调整以实现环境中的更改 (人类不会经历闭合的门!)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="ce9a5-186">网格可能需要进行一些[处理](spatial-mapping.md#mesh-processing)才能用于通过虚拟字符进行路径规划和导航。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="ce9a5-187">平滑网格和删除 hallucinations 可帮助避免字符停滞。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="ce9a5-188">您还可能希望大幅简化网格, 以加快字符的路径规划和导航计算速度。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="ce9a5-189">在开发 videogame 技术时, 这些挑战已经获得了很大的关注, 其中提供了大量有关这些主题的信息。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="ce9a5-190">请注意, Unity 中的内置 NavMesh 功能不能与空间映射图面一起使用。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="ce9a5-191">这是因为在应用程序启动之前空间映射表面是未知的, 而需要提前从源资产生成 NavMesh 数据文件。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="ce9a5-192">另请注意, 空间映射系统不会提供与用户当前位置[有关的有关表面的信息](spatial-mapping-design.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="ce9a5-193">因此, 如果应用程序要生成非常大的区域的地图, 则必须 "记住" 自己的图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="ce9a5-194">视觉</span><span class="sxs-lookup"><span data-stu-id="ce9a5-194">Visualization</span></span>

<span data-ttu-id="ce9a5-195">大多数情况都适用于空间图面不可见;为了最大程度地减少视觉干扰, 并让现实世界亲自讲述。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="ce9a5-196">但是, 有时可以直接直观显示空间图图面, 尽管它们的实际对应项已经可见。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="ce9a5-197">例如, 当用户尝试将一个全息图放到图面上 (例如, 将一个全息文件柜置于墙壁上时), 通过将阴影转换到图面上来 "地面" 就很有用。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="ce9a5-198">这样, 用户就可以更清楚地了解全息图和表面之间的确切物理距离。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="ce9a5-199">这也是在用户提交到用户之前, 直观地预览更改的更通用的示例。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="ce9a5-200">通过可视化图面, 应用程序可以与用户共享其环境的了解。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="ce9a5-201">例如, 全息板游戏可能会将其标识为 "表" 的水平表面可视化, 因此用户知道应该在何处交互。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="ce9a5-202">可视化图面可用于向用户显示在视图中隐藏的附近的用户。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="ce9a5-203">这可能会提供一种简单的方法, 使用户能够从生活空间访问其厨房 (及其包含的所有全息影像)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="ce9a5-204">空间映射提供的 surface 网格可能不是特别 "干净的"。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="ce9a5-205">因此, 对其进行适当的可视化非常重要。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="ce9a5-206">传统的照明计算可能会以视觉上分散的方式突出显示曲面法线中的错误, 而投影到表面的 "干净" 纹理可能有助于使其成为整齐的外观。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="ce9a5-207">在呈现表面之前, 还可以执行[网格处理](spatial-mapping.md#mesh-processing)来改善网格属性。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="ce9a5-208">使用 Surface 观察器</span><span class="sxs-lookup"><span data-stu-id="ce9a5-208">Using The Surface Observer</span></span>

<span data-ttu-id="ce9a5-209">空间映射的起始点为 surface 观察程序。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="ce9a5-210">程序流如下所示:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-210">Program flow is as follows:</span></span>
* <span data-ttu-id="ce9a5-211">创建 surface 观察器对象</span><span class="sxs-lookup"><span data-stu-id="ce9a5-211">Create a surface observer object</span></span>
   * <span data-ttu-id="ce9a5-212">提供一个或多个空间卷, 以定义应用程序希望接收空间映射数据的感兴趣的区域。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="ce9a5-213">空间量只是定义空间区域的形状, 例如球或 box。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="ce9a5-214">使用带有世界锁定的空间坐标系统的空间量来识别物理世界的固定区域。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="ce9a5-215">使用空间量, 使用正文锁定的空间坐标系统更新每个帧, 以标识与用户移动 (但不能旋转) 的空间区域。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="ce9a5-216">以后可以随时更改这些空间卷, 因为应用程序或用户的状态会发生更改。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="ce9a5-217">使用轮询或通知来检索有关空间图面的信息</span><span class="sxs-lookup"><span data-stu-id="ce9a5-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="ce9a5-218">您可以随时 "轮询" 面观察器来实现空间图面状态。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="ce9a5-219">或者, 你可以为 surface 观察器的 "surface changed" 事件注册, 这会在空间表面发生更改时通知应用程序。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="ce9a5-220">对于动态空间量 (如视图截锥或正文锁定卷), 应用程序需要通过设置感兴趣的区域, 然后获取当前的空间图面集来轮询每个帧的更改。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="ce9a5-221">对于静态卷 (如涵盖单个房间的全球锁定的多维数据集), 应用程序可能会注册 "已更改" 事件, 以便在该卷内的空间表面发生变化时得到通知。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="ce9a5-222">处理表面更改</span><span class="sxs-lookup"><span data-stu-id="ce9a5-222">Process surfaces changes</span></span>
   * <span data-ttu-id="ce9a5-223">循环访问提供的空间图面集。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="ce9a5-224">按添加、更改或删除的方式对空间图面进行分类。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="ce9a5-225">对于每个已添加或已更改的空间图面, 如果适当, 请提交一个异步请求, 以在所需的详细信息级别接收表示该图面的当前状态的已更新网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="ce9a5-226">处理异步网格请求 (以下部分中的详细信息)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="ce9a5-227">网格缓存</span><span class="sxs-lookup"><span data-stu-id="ce9a5-227">Mesh Caching</span></span>

<span data-ttu-id="ce9a5-228">空间图面由密集三角形网格表示。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="ce9a5-229">存储、呈现和处理这些网格可能会占用大量计算和存储资源。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="ce9a5-230">因此, 每个应用程序应采用适合于其需要的网格缓存方案, 以最大程度地减少用于网格处理和存储的资源。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="ce9a5-231">此方案应该确定要保留哪些网格以及要丢弃哪些网格, 以及何时更新每个空间图面的网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="ce9a5-232">其中所述的许多注意事项将直接通知您的应用程序应该如何处理网格缓存。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="ce9a5-233">当观察到不同的表面以及应捕获环境中的更改时, 您应考虑用户在环境中的移动方式、需要的表面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="ce9a5-234">当解释 surface 观察器提供的 "表面变化" 事件时, 基本网格缓存逻辑如下所示:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="ce9a5-235">如果应用程序看到之前未出现过的空间表面 ID, 则它应将其视为新的空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="ce9a5-236">如果应用程序看到具有已知 ID 但具有新更新时间的空间图面, 则它应将其视为更新的空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="ce9a5-237">如果应用程序不再看到具有已知 ID 的空间图面, 则它应将其视为已删除的空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="ce9a5-238">在每个应用程序中, 然后进行以下选择:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="ce9a5-239">对于新空间图面, 是否应请求网格？</span><span class="sxs-lookup"><span data-stu-id="ce9a5-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="ce9a5-240">通常应立即为新的空间图面请求网格, 这可能会向用户提供有用的新信息。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="ce9a5-241">但是, 在用户面前附近和之前的新空间图面应优先, 并首先请求其网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="ce9a5-242">如果不需要新网格, 则为; 例如, 如果应用程序永久或临时 "冻结" 其环境模型, 则不应请求它。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="ce9a5-243">对于已更新的空间图面, 是否应请求网格？</span><span class="sxs-lookup"><span data-stu-id="ce9a5-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="ce9a5-244">应将已更新的空间图面置于用户面前, 并应首先请求其网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="ce9a5-245">对于新曲面, 更高优先级的优先级可能更高, 特别是在扫描体验过程中。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="ce9a5-246">为了限制处理成本, 应用程序可能希望限制它们处理空间图面更新的速率。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="ce9a5-247">可以推断出对空间图面所做的更改很小, 例如, 如果图面的边界很小, 则更新可能不太重要, 无法处理。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="ce9a5-248">对于用户感兴趣的当前区域之外的空间表面的更新, 可能会完全忽略, 但是在这种情况下, 修改 surface 观察器使用的空间边界卷可能更有效。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="ce9a5-249">对于删除的空间表面, 是否应丢弃网格？</span><span class="sxs-lookup"><span data-stu-id="ce9a5-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="ce9a5-250">通常应为删除的空间图面立即丢弃网格, 使全息图封闭保持正确。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="ce9a5-251">但是, 如果应用程序有理由相信某个空间图面很快就会重新出现 (或许基于用户体验的设计), 则保留它比丢弃其网格并在以后重新创建它更有效。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="ce9a5-252">如果应用程序正在生成用户环境的大规模模型, 则可能不希望全部丢弃任何网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="ce9a5-253">不过, 它仍需要限制资源使用情况, 可能通过将网格后台打印到磁盘, 因为空间图面消失。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="ce9a5-254">请注意, 在空间表面生成过程中, 某些相对罕见的事件可能会导致空间图面替换为类似位置但 Id 不同的新空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="ce9a5-255">因此, 选择不放弃已移除表面的应用程序应注意不会有多个高度重叠的空间表面网格覆盖同一位置。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="ce9a5-256">是否应为任何其他空间图面丢弃网格？</span><span class="sxs-lookup"><span data-stu-id="ce9a5-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="ce9a5-257">即使存在空间图面, 如果它对用户体验不再有用, 则应将其丢弃。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="ce9a5-258">例如, 如果应用程序 "将门口的另一侧的空间替换为备用虚拟空间, 则该房间中的空间表面将不再重要。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="ce9a5-259">下面是使用空间和时态滞后的示例网状缓存策略:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="ce9a5-260">假设有一个应用程序, 该应用程序想要在观看和四处浏览时使用在用户的 "注视" 周围的 "截锥" 空间量。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="ce9a5-261">空间表面可能会暂时从此卷中消失, 这只是因为用户看起来远离图面或其他步骤 .。。仅供稍后再次查找或更近一段时间。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="ce9a5-262">在这种情况下, 放弃并重新创建此图面的网格表示大量冗余处理。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="ce9a5-263">为了减少处理的更改的数量, 应用程序将使用两个空间图面观察器, 其中一个包含在另一个中。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="ce9a5-264">较大的卷为球状, 并跟随用户 "延迟";它仅在必要时才会移动, 以确保其中心在用户的 2.0 metres 范围内。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="ce9a5-265">新的和更新的空间 surface 网格始终从较小的内部面观察程序进行处理, 但会缓存网格, 直到它们从较大的外部表面观察器消失。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="ce9a5-266">这使应用程序可以避免因本地用户移动而处理许多冗余更改。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="ce9a5-267">由于由于跟踪丢失, 空间图面也可能暂时消失, 因此, 应用程序也会在跟踪丢失期间放弃删除的空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="ce9a5-268">通常情况下, 应用程序应评估减少的更新处理和增加的内存使用情况之间的折衷, 以确定其理想的缓存策略。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="ce9a5-269">渲染</span><span class="sxs-lookup"><span data-stu-id="ce9a5-269">Rendering</span></span>

<span data-ttu-id="ce9a5-270">空间映射网格通常用于呈现的主要方式有三种:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="ce9a5-271">用于表面可视化</span><span class="sxs-lookup"><span data-stu-id="ce9a5-271">For surface visualization</span></span>
   * <span data-ttu-id="ce9a5-272">它通常有助于直接可视化空间图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="ce9a5-273">例如, 将 "shadows" 从对象强制转换为空间图面时, 可以向用户提供更好的视觉反馈。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="ce9a5-274">需要注意的一点是, 空间网格不同于三维艺术家可能创建的网格类型。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="ce9a5-275">三角形拓扑不会作为用户创建的拓扑 "干净", 并且网格会受到[各种错误](spatial-mapping-design.md#what-influences-spatial-mapping-quality)的影响。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="ce9a5-276">为了创建令人满意的视觉对象美观, 可能需要执行一些[网格处理](spatial-mapping.md#mesh-processing), 例如填充孔或平滑曲面法。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="ce9a5-277">您还可能希望使用着色器将艺术家设计的纹理投影到网格上, 而不是直接可视化网格拓扑和法线。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="ce9a5-278">对于真实的图面后面的 occluding 全息影像</span><span class="sxs-lookup"><span data-stu-id="ce9a5-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="ce9a5-279">空间图面可以在仅深度传递中呈现, 这只会影响[深度缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)并且不会影响颜色呈现器目标。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="ce9a5-280">这会 primes 深度缓冲区以遮蔽随后呈现的空间表面上呈现的全息影像。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="ce9a5-281">最准确的全息影像封闭增强了全息影像在用户的物理空间内确实存在的意义。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="ce9a5-282">若要启用仅深度渲染, 请更新混合状态, 将所有颜色渲染目标的[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)设置为零。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="ce9a5-283">用于修改真实环境中全息图封闭像素的外观</span><span class="sxs-lookup"><span data-stu-id="ce9a5-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="ce9a5-284">当封闭像素时, 通常会隐藏呈现的几何图形。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="ce9a5-285">这是通过将[深度-模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中的深度函数设置为 "小于或等于" 来实现的, 这会使几何仅在**离相机更近**的位置 (而不是所有先前呈现的几何图形) 可见。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="ce9a5-286">但是, 即使在封闭像素时仍可查看某些几何, 并在封闭像素作为向用户提供视觉反馈的方式时修改其外观, 这可能会很有用。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="ce9a5-287">例如, 这允许应用程序向用户显示对象的位置, 同时使其清楚地显示在实际表面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="ce9a5-288">若要实现此目的, 请使用另一个创建所需 "封闭像素" 外观的着色器第二次渲染几何。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="ce9a5-289">在第二次渲染几何之前, 对[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)进行两次更改。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="ce9a5-290">首先, 将 "深度函数" 设置为 "大于或等于", 以便仅在其从相机中的**其他**位置 (而不是所有先前呈现的几何图形) 中可见。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="ce9a5-291">其次, 将 DepthWriteMask 设置为零, 以便不会修改深度缓冲区 (深度缓冲区应继续表示**距离相机最近**的几何图形的深度)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="ce9a5-292">在呈现空间映射网格时,[性能](understanding-performance-for-mixed-reality.md)是一个重要的考虑因素。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="ce9a5-293">下面是一些特定于呈现空间映射网格的呈现性能技巧:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="ce9a5-294">调整三角形密度</span><span class="sxs-lookup"><span data-stu-id="ce9a5-294">Adjust triangle density</span></span>
   * <span data-ttu-id="ce9a5-295">从 surface 观察者请求空间表面网格时, 请求可满足您需求的最小的三角形网格密度。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="ce9a5-296">在图面上改变三角密度可能有意义, 具体取决于表面与用户的距离以及与用户体验的相关性。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="ce9a5-297">减少三角形计数将减少 GPU 上的内存使用量和顶点处理开销, 但它不会影响像素处理开销。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="ce9a5-298">执行截锥剔除</span><span class="sxs-lookup"><span data-stu-id="ce9a5-298">Perform frustum culling</span></span>
   * <span data-ttu-id="ce9a5-299">截锥剔除会跳过无法看见的绘图对象, 因为它们在当前显示的 "截锥" 之外。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="ce9a5-300">这同时降低了 CPU 和 GPU 处理成本。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="ce9a5-301">由于剔除是根据每个网格进行的, 空间表面可能会很大, 因此, 将每个空间曲面网格分解为较小的区块可能会导致更有效的剔除 (在这种情况下, 将呈现更少的屏幕外三角形)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="ce9a5-302">不过, 有一种折衷:您拥有的网格越多, 您必须进行的绘图调用越多, 这会增加 CPU 开销。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="ce9a5-303">在极端情况下, 如截锥剔除计算, 甚至可能有可度量的 CPU 开销。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="ce9a5-304">调整呈现顺序</span><span class="sxs-lookup"><span data-stu-id="ce9a5-304">Adjust rendering order</span></span>
   * <span data-ttu-id="ce9a5-305">空间表面很大, 因为它们代表用户在周围的整个环境。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="ce9a5-306">因此, GPU 上的像素处理开销可能很高, 尤其是在有多个可见几何层 (包括空间表面和其他全息影像) 的情况下。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="ce9a5-307">在这种情况下, 离用户最近的层会进一步 occluding 任何层, 因此, 在呈现这些更远距离的层所用的任何 GPU 时间都将浪费下来。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="ce9a5-308">若要减少 GPU 上的这一冗余工作, 这有助于以从前到后的顺序呈现不透明的图面 (首先是更接近的图面)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="ce9a5-309">"不透明" 是指在您的[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中将 DepthWriteMask 设置为一个的表面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="ce9a5-310">当呈现最近的图面时, 它们将成为深度缓冲区的质数, 以便 GPU 上的像素处理器有效地跳过更远的图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="ce9a5-311">网格处理</span><span class="sxs-lookup"><span data-stu-id="ce9a5-311">Mesh Processing</span></span>

<span data-ttu-id="ce9a5-312">应用程序可能希望对空间 surface 网格执行[各种操作](spatial-mapping.md#mesh-processing)以满足其需求。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="ce9a5-313">每个空间 surface 网格提供的索引和顶点数据与用于在所有新式渲染 Api 中呈现三角形网格的[顶点和索引缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)使用的布局相同。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="ce9a5-314">不过, 有一个关键事实需要注意的是, 空间映射三角形具有**前后的缠绕顺序**。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="ce9a5-315">每个三角形都用网格的索引缓冲区中的三个顶点索引表示, 当从**正面**查看三角形时, 这些索引会按**顺时针**顺序标识三角形的顶点。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="ce9a5-316">空间 surface 网格的正面 (或外部) 对应于实际表面正面 (可见) 的位置。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="ce9a5-317">如果 surface 观察器提供的益处三角形密度仍不足粗, 则应用程序应仅执行网格简化, 这种工作的计算成本高昂, 并且已由运行时执行以生成各种提供的详细信息级别。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="ce9a5-318">由于每个 surface 观察器都可以提供多个未连接的空间图面, 因此某些应用程序可能希望彼此剪裁这些空间 surface 网格, 然后将它们 zipper 在一起。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="ce9a5-319">通常, 剪裁步骤是必需的, 因为附近的空间 surface 网格通常会稍微重叠。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="ce9a5-320">Raycasting 和冲突</span><span class="sxs-lookup"><span data-stu-id="ce9a5-320">Raycasting and Collision</span></span>

<span data-ttu-id="ce9a5-321">为了使物理 API (如[Havok](http://www.havok.com/)) 能够为空间图面提供具有 raycasting 和碰撞功能的应用程序, 应用程序必须向物理学 API 提供空间 surface 网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="ce9a5-322">用于物理学的网格通常具有以下属性:</span><span class="sxs-lookup"><span data-stu-id="ce9a5-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="ce9a5-323">它们只包含少量三角形。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="ce9a5-324">物理运算比呈现操作要多得多。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="ce9a5-325">它们是 "水紧的"。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-325">They are 'water-tight'.</span></span> <span data-ttu-id="ce9a5-326">应为实心的表面不应具有小孔;即使洞太小, 也可能会导致问题。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="ce9a5-327">它们将转换为凸 hulls。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-327">They are converted into convex hulls.</span></span> <span data-ttu-id="ce9a5-328">凸 hulls 有几个多边形, 并且没有孔, 它们的计算效率比原始三角形网格要高得多。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="ce9a5-329">针对空间图面执行 raycasts 时, 请记住, 这些图面通常是复杂的、杂乱的形状, 几乎不会有杂乱的细节, 就像您的办公桌一样!</span><span class="sxs-lookup"><span data-stu-id="ce9a5-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="ce9a5-330">这意味着, 单个 raycast 通常不能为您给出有关图面的形状和附近的空白空间形状的足够信息。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="ce9a5-331">因此, 通常最好在一个较小的区域中执行许多 raycasts, 并使用聚合结果来更可靠地了解图面。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="ce9a5-332">例如, 使用平均 10 raycasts 来指导图面上的全息影像布局将产生比只使用单个 raycast 更流畅和更小的 "抖动" 结果。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="ce9a5-333">不过, 请记住, 每个 raycast 都有一个较高的计算成本。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="ce9a5-334">因此, 根据使用方案, 你应将其他 raycasts (每个帧执行的计算成本) 的计算成本与[网格处理](spatial-mapping.md#mesh-processing)的计算成本进行权衡, 以平滑和删除空间图面中的孔 (当空间更新了网格)。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="ce9a5-335">疑难解答</span><span class="sxs-lookup"><span data-stu-id="ce9a5-335">Troubleshooting</span></span>
* <span data-ttu-id="ce9a5-336">为了使 surface 网格正确面向, 每个 GameObject 都需要处于活动状态, 然后才能将其发送到 SurfaceObeserver 来构造其网格。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="ce9a5-337">否则, 网格将显示在您的空间中, 但会旋转为古怪度。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="ce9a5-338">需要将运行与 SurfaceObserver 通信的脚本的 GameObject 设置为源。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="ce9a5-339">否则, 你创建并发送到 SurfaceObserver 的所有 Gameobject 都具有与父游戏对象的偏移量相等的偏移量。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="ce9a5-340">这会使你的网格显示多个计量仪, 这使得调试正在进行的操作非常困难。</span><span class="sxs-lookup"><span data-stu-id="ce9a5-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="ce9a5-341">请参阅</span><span class="sxs-lookup"><span data-stu-id="ce9a5-341">See also</span></span>
* [<span data-ttu-id="ce9a5-342">坐标系统</span><span class="sxs-lookup"><span data-stu-id="ce9a5-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="ce9a5-343">DirectX 中的空间映射</span><span class="sxs-lookup"><span data-stu-id="ce9a5-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="ce9a5-344">Unity 中的空间映射</span><span class="sxs-lookup"><span data-stu-id="ce9a5-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="ce9a5-345">空间映射设计</span><span class="sxs-lookup"><span data-stu-id="ce9a5-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="ce9a5-346">案例研究 - 看透现实中的洞</span><span class="sxs-lookup"><span data-stu-id="ce9a5-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
