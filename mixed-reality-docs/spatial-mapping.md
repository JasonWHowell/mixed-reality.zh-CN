---
title: 空间映射
description: 空间映射提供了 HoloLens 周围环境中的实际表面的详细表示形式。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射、 HoloLens、 混合的现实、 图面上重新构造、 网格、 sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/12/2019
ms.locfileid: "59593056"
---
# <a name="spatial-mapping"></a><span data-ttu-id="f9d70-104">空间映射</span><span class="sxs-lookup"><span data-stu-id="f9d70-104">Spatial mapping</span></span>

<span data-ttu-id="f9d70-105">空间映射提供了 HoloLens，围绕环境中的实际表面的详细的表示允许开发人员创建令人信服的混合的现实体验。</span><span class="sxs-lookup"><span data-stu-id="f9d70-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="f9d70-106">通过合并虚拟世界与现实世界，应用程序可以使全息看起来真实。</span><span class="sxs-lookup"><span data-stu-id="f9d70-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="f9d70-107">应用程序还可以更自然对齐与用户的期望通过提供熟悉的实际行为和交互。</span><span class="sxs-lookup"><span data-stu-id="f9d70-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="f9d70-108">设备支持</span><span class="sxs-lookup"><span data-stu-id="f9d70-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="f9d70-109">功能</span><span class="sxs-lookup"><span data-stu-id="f9d70-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="f9d70-110"><a href="hololens-hardware-details.md">HoloLens （第 1 代）</a></span><span class="sxs-lookup"><span data-stu-id="f9d70-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="f9d70-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="f9d70-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="f9d70-112"><a href="immersive-headset-hardware-details.md">沉浸式耳机</a></span><span class="sxs-lookup"><span data-stu-id="f9d70-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="f9d70-113">空间映射</span><span class="sxs-lookup"><span data-stu-id="f9d70-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="f9d70-114">✔️</span><span class="sxs-lookup"><span data-stu-id="f9d70-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="f9d70-115">✔️</span><span class="sxs-lookup"><span data-stu-id="f9d70-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="f9d70-116">概念性概述</span><span class="sxs-lookup"><span data-stu-id="f9d70-116">Conceptual overview</span></span>

<span data-ttu-id="f9d70-117">![网格图面涵盖聊天室](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="f9d70-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="f9d70-118">*举例说明了空间映射网格涵盖聊天室*</span><span class="sxs-lookup"><span data-stu-id="f9d70-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="f9d70-119">用于空间映射的两个主要对象类型是空间面观察者和空间面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="f9d70-120">应用程序提供了空间面观察程序提供一个或多个边界卷，若要定义的应用程序希望接收空间映射数据的空间区域。</span><span class="sxs-lookup"><span data-stu-id="f9d70-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="f9d70-121">对于每个这些卷，空间映射将提供一组空间曲面的应用程序。</span><span class="sxs-lookup"><span data-stu-id="f9d70-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="f9d70-122">这些卷可能处于静止状态 （相对于现实世界的固定位置） 或可能将它们附加到 HoloLens （它们移动，但不是会旋转，与 HoloLens 流过环境）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="f9d70-123">每个空间的图面描述中表示为附加到世界上锁定三角形网格的空间量很小的实际表面[空间坐标系统](coordinate-systems.md)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="f9d70-124">作为 HoloLens 收集新数据有关的环境中，对环境的更改发生时，将出现空间表面，消失，并将更改。</span><span class="sxs-lookup"><span data-stu-id="f9d70-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="f9d70-125">常见使用方案</span><span class="sxs-lookup"><span data-stu-id="f9d70-125">Common usage scenarios</span></span>

![空间映射的常见使用方案的说明：放置、 封闭、 物理和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="f9d70-127">放置</span><span class="sxs-lookup"><span data-stu-id="f9d70-127">Placement</span></span>

<span data-ttu-id="f9d70-128">空间映射提供了使用可以提供给用户; 简单自然且熟悉的交互的窗体应用程序还有什么能比在办公桌上向下放置你的手机更自然？</span><span class="sxs-lookup"><span data-stu-id="f9d70-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="f9d70-129">约束全息的位置 (或更普遍的情况，任何选择的空间位置) 将位于其图面上提供的自然映射从 3D （点空间） 到 2D （在图面上的点）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="f9d70-130">这将减少用户需要提供给应用程序，这样可以使用户的交互更快、 更轻松、 更精确的信息量。</span><span class="sxs-lookup"><span data-stu-id="f9d70-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="f9d70-131">因为距离之外不是我们习惯于以物理方式通信到其他人或计算机，也是如此。</span><span class="sxs-lookup"><span data-stu-id="f9d70-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="f9d70-132">当我们点与我们的手指时，我们指定方向，但不是了的距离。</span><span class="sxs-lookup"><span data-stu-id="f9d70-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="f9d70-133">一个重要的注意事项是，当应用程序来推断方向的距离 (例如通过执行查找最接近用户的视线移动方向 raycast 空间图面)，这必须产生用户是否能够可靠地预测的结果。</span><span class="sxs-lookup"><span data-stu-id="f9d70-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="f9d70-134">否则为该用户将失去其意义上的控件，这很快会令人沮丧。</span><span class="sxs-lookup"><span data-stu-id="f9d70-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="f9d70-135">这将帮助的一种方法是执行多个 raycasts 而不是只需一个。</span><span class="sxs-lookup"><span data-stu-id="f9d70-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="f9d70-136">聚合结果应更流畅和可预测、 不易受到影响从暂时性离群值的结果 （如可能引起大气通过微小的漏洞或达到小段几何图形，它并不知道用户）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="f9d70-137">聚合或平滑处理也可以随时间;例如，您可以限制在距离用户改变一张全息图可以最大速度。</span><span class="sxs-lookup"><span data-stu-id="f9d70-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="f9d70-138">只限制最小值和最大距离值还可以帮助，因此要移动的全息图不会不突然消失飞入距离或崩溃恢复到用户的人脸。</span><span class="sxs-lookup"><span data-stu-id="f9d70-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="f9d70-139">应用程序还可以使用的形状和方向的表面指南全息图放置到。</span><span class="sxs-lookup"><span data-stu-id="f9d70-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="f9d70-140">Holographic 椅子不应通过墙壁入侵和应位于刷新与 floor 即使略有不均。</span><span class="sxs-lookup"><span data-stu-id="f9d70-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="f9d70-141">此类功能可能会依赖于物理冲突而不是只是 raycasts，但是类似的问题将应用的使用。</span><span class="sxs-lookup"><span data-stu-id="f9d70-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="f9d70-142">如果正在放置的全息图具有伸出，如椅子上, legs 的许多小多边形它很有用的物理表示形式的多边形扩展到更宽且更流畅的内容，以便他们可更多空间表面，而无需通过滑动截图。</span><span class="sxs-lookup"><span data-stu-id="f9d70-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="f9d70-143">其一种极端情况，用户输入可以简化即可完全和图面空间可用于执行完全自动全息图放置。</span><span class="sxs-lookup"><span data-stu-id="f9d70-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="f9d70-144">例如，应用程序无法将置于全息版的灯开关某处在用户按墙上。</span><span class="sxs-lookup"><span data-stu-id="f9d70-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="f9d70-145">有关可预测性的同一注意事项适用双向此处;如果用户需要控制全息图放置功能，但应用程序不会始终施加全息他们预期 （如果灯开关显示用户无法访问的某个位置） 的位置，这将是令人沮丧的体验。</span><span class="sxs-lookup"><span data-stu-id="f9d70-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="f9d70-146">它实际上可能更糟的是执行自动放置功能，需要用户更正一些时间，比以只需要求用户始终会执行放置本身;因为成功的自动放置*预期*，手动更正让人感觉像负担 ！</span><span class="sxs-lookup"><span data-stu-id="f9d70-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="f9d70-147">另请注意，应用程序的位置很大程度取决于应用程序的使用空间表面的功能[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="f9d70-148">如果尚未扫描图面，然后它不能用于放置。</span><span class="sxs-lookup"><span data-stu-id="f9d70-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="f9d70-149">它是由应用程序为了明确这给用户，以便他们也可以帮助扫描新的图面或选择新的位置。</span><span class="sxs-lookup"><span data-stu-id="f9d70-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="f9d70-150">向用户的可视反馈是在放置过程中极其重要。</span><span class="sxs-lookup"><span data-stu-id="f9d70-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="f9d70-151">用户需要知道其中全息图是相对于使用最接近的图面[接地效果](spatial-mapping.md#visualization)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="f9d70-152">它们应了解其全息图的移动 （例如，由于与另一个邻近的图面发生冲突） 约束的原因。</span><span class="sxs-lookup"><span data-stu-id="f9d70-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="f9d70-153">如果它们不能将一张全息图放在当前的位置，然后可视反馈应使它为什么不清除。</span><span class="sxs-lookup"><span data-stu-id="f9d70-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="f9d70-154">例如，如果用户正尝试放置 holographic couch 停滞一半到墙上插座，然后躺椅后面墙上插座的部分应 pulsate 因为什么而怒气冲冲的颜色。</span><span class="sxs-lookup"><span data-stu-id="f9d70-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="f9d70-155">或反之，如果应用程序在其中用户可以看到实际的图面位置找不到空间图面，然后在应用程序应清楚这。</span><span class="sxs-lookup"><span data-stu-id="f9d70-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="f9d70-156">明显缺少此区域中的接地效果可能会达到此目的。</span><span class="sxs-lookup"><span data-stu-id="f9d70-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="f9d70-157">封闭</span><span class="sxs-lookup"><span data-stu-id="f9d70-157">Occlusion</span></span>

<span data-ttu-id="f9d70-158">空间映射图面的主要用途之一就是遮蔽全息。</span><span class="sxs-lookup"><span data-stu-id="f9d70-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="f9d70-159">此简单行为全息，帮助创建 visceral 即真正占据的与用户相同的物理空间感知真实性上具有很大的影响。</span><span class="sxs-lookup"><span data-stu-id="f9d70-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="f9d70-160">封闭还向用户; 提供的信息一张全息图看起来封闭的实际的图面，这样该 hologram 世界上的空间位置的其他可视反馈。</span><span class="sxs-lookup"><span data-stu-id="f9d70-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="f9d70-161">相反，封闭可以也有用*隐藏*来自用户的信息; occluding 全息背后墙可以减少视觉混乱中以直观的方式。</span><span class="sxs-lookup"><span data-stu-id="f9d70-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="f9d70-162">若要隐藏或显示一张全息图，用户只是必须移动其头。</span><span class="sxs-lookup"><span data-stu-id="f9d70-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="f9d70-163">此外可以使用封闭来准备对基于熟悉的物理交互; 自然的用户界面的期望如果一张全息图封闭的图面是因为该图面是稳定的因此用户应期待全息图将*发生碰撞*的面上，并通过它不是简单地传递。</span><span class="sxs-lookup"><span data-stu-id="f9d70-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="f9d70-164">有时，封闭全息并不可取。</span><span class="sxs-lookup"><span data-stu-id="f9d70-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="f9d70-165">如果用户需要能够与一张全息图进行交互，然后他们需要能够看到它-即使位于实际的图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="f9d70-166">在这种情况下，它通常有意义时它封闭的像素 （例如，通过减少其亮度） 以不同的方式呈现此类一张全息图。</span><span class="sxs-lookup"><span data-stu-id="f9d70-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="f9d70-167">这样一来，用户将能够直观地找到全息图，但它们仍会知道它位于后面的内容。</span><span class="sxs-lookup"><span data-stu-id="f9d70-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="f9d70-168">物理引擎</span><span class="sxs-lookup"><span data-stu-id="f9d70-168">Physics</span></span>

<span data-ttu-id="f9d70-169">使用物理模拟是另一种方式在哪些空间映射可用于加强*存在*全息用户的物理空间中。</span><span class="sxs-lookup"><span data-stu-id="f9d70-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="f9d70-170">当我 holographic 橡胶球实际上将关闭我的书桌、 跨 floor 退回并消失在躺椅下时，可能会很为我相信，它是不实际存在。</span><span class="sxs-lookup"><span data-stu-id="f9d70-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="f9d70-171">物理模拟还提供了应用程序使用简单自然且熟悉的物理交互的机会。</span><span class="sxs-lookup"><span data-stu-id="f9d70-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="f9d70-172">将一种围绕 holographic 家具移动的地板上很可能是便于用户如果家具响应就好像它已在使用适当的延时和冲突的下限之间滑动。</span><span class="sxs-lookup"><span data-stu-id="f9d70-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="f9d70-173">为了生成实际的物理行为，可能需要执行一些[mesh 处理](spatial-mapping.md#mesh-processing)填充漏洞，如删除浮动 hallucinations 和平滑的大致图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="f9d70-174">您还需要考虑如何应用程序[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)会影响其物理模拟。</span><span class="sxs-lookup"><span data-stu-id="f9d70-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="f9d70-175">首先，缺少表面不会与任何内容;当关闭走廊和关闭已知世界末日橡胶球滚动关闭时，会发生什么情况？</span><span class="sxs-lookup"><span data-stu-id="f9d70-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="f9d70-176">其次，您需要决定是否仍将随着时间的推移对环境中的更改作出响应。</span><span class="sxs-lookup"><span data-stu-id="f9d70-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="f9d70-177">在某些情况下，您将希望尽快; 响应假设是否用户使用门和家具作为可移动 barricades 中对传入 Roman 箭头 tempest 的防御。</span><span class="sxs-lookup"><span data-stu-id="f9d70-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="f9d70-178">在其他情况下，你可能想要忽略新的更新;在地板上推动周围赛场你 holographic 跑车突然不可能或宠物狗决定坐在中间跟踪太有趣了。</span><span class="sxs-lookup"><span data-stu-id="f9d70-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="f9d70-179">导航</span><span class="sxs-lookup"><span data-stu-id="f9d70-179">Navigation</span></span>

<span data-ttu-id="f9d70-180">应用程序可以使用数据空间映射授予 holographic 字符 （或代理） 与真实的人将相同的方式导航现实世界的能力。</span><span class="sxs-lookup"><span data-stu-id="f9d70-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="f9d70-181">这可以帮助加强全息版的存在通过限制对一组相同的自然、 熟悉的用户和他们的朋友的行为。</span><span class="sxs-lookup"><span data-stu-id="f9d70-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="f9d70-182">导航功能可能对用户非常有用。</span><span class="sxs-lookup"><span data-stu-id="f9d70-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="f9d70-183">在给定区域中生成导航图之后, 它无法共享与该位置提供的新用户不熟悉 holographic 方向。</span><span class="sxs-lookup"><span data-stu-id="f9d70-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="f9d70-184">无法设计此映射，以帮助保持显呆板通信非常顺利，或避免事故等建筑工地的危险位置中。</span><span class="sxs-lookup"><span data-stu-id="f9d70-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="f9d70-185">关键的技术挑战参与实现导航功能将是可靠检测到的移动应用层协议 （人类不审核表 ！） 和正常适应 （人类不演练已关闭的大门 ！） 的环境中的更改。</span><span class="sxs-lookup"><span data-stu-id="f9d70-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="f9d70-186">网格可能需要一些[处理](spatial-mapping.md#mesh-processing)是可用于路径规划和导航虚拟字符之前。</span><span class="sxs-lookup"><span data-stu-id="f9d70-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="f9d70-187">平滑处理网格和删除 hallucinations 可能有助于避免成为停滞的字符。</span><span class="sxs-lookup"><span data-stu-id="f9d70-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="f9d70-188">您可能还希望极大地简化为了加快您的人物路径规划和导航计算网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="f9d70-189">这些挑战的视频游戏设备技术开发中收到大量的关注和丰富的发布的调查宣传资料中对这些主题。</span><span class="sxs-lookup"><span data-stu-id="f9d70-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="f9d70-190">请注意在 Unity 中的内置 NavMesh 功能不能用于空间映射图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="f9d70-191">这是因为空间映射图面之前未知的应用程序启动，而需要从提前源资产生成 NavMesh 数据文件。</span><span class="sxs-lookup"><span data-stu-id="f9d70-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="f9d70-192">另请注意，将不会提供空间映射系统[信息非常远面](spatial-mapping-design.md#the-environment-scanning-experience)从用户的当前位置。</span><span class="sxs-lookup"><span data-stu-id="f9d70-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="f9d70-193">使应用程序必须记住图面本身如果它是用于生成非常大的区域的映射。</span><span class="sxs-lookup"><span data-stu-id="f9d70-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="f9d70-194">可视化效果</span><span class="sxs-lookup"><span data-stu-id="f9d70-194">Visualization</span></span>

<span data-ttu-id="f9d70-195">大多数情况下它是适用于空间表面不可见;最大程度减少视觉混乱，并允许真实世界自己说话。</span><span class="sxs-lookup"><span data-stu-id="f9d70-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="f9d70-196">但是，有时它很直接，尽管它们实际的对应项都已经可见可视化空间映射图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="f9d70-197">例如，当用户正尝试放置到图面 （全息版的 cab 文件上放置墙上插座，说） 上一张全息图可用于接地 hologram 通过在图面进行投影。</span><span class="sxs-lookup"><span data-stu-id="f9d70-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="f9d70-198">这使用户更清楚了解确切物理邻近区域之间全息图和图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="f9d70-199">这也是以可视方式预览更改之前提交给它的用户的更多常规做法的示例。</span><span class="sxs-lookup"><span data-stu-id="f9d70-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="f9d70-200">通过可视化图面，该应用程序可以与用户共享其了解环境。</span><span class="sxs-lookup"><span data-stu-id="f9d70-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="f9d70-201">例如，holographic 棋盘类游戏能够呈现水平的图面，则已标识为表以便让用户知道他们应发送到何处进行交互。</span><span class="sxs-lookup"><span data-stu-id="f9d70-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="f9d70-202">可视化图面可以是有用的方式向用户显示附近的视图中隐藏的空格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="f9d70-203">这可能从其起居室提供简单的方法，以允许用户访问其厨房 （和所有其包含全息）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="f9d70-204">提供的空间映射图面上网格可能不是特别清理。</span><span class="sxs-lookup"><span data-stu-id="f9d70-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="f9d70-205">因此请务必相应地将其可视化。</span><span class="sxs-lookup"><span data-stu-id="f9d70-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="f9d70-206">传统的照明计算可能会突出显示错误中曲面法线以直观地让人分散注意力的方式，同时投影到图面上的清理纹理可帮助使其整洁的外观。</span><span class="sxs-lookup"><span data-stu-id="f9d70-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="f9d70-207">还有可能执行[mesh 处理](spatial-mapping.md#mesh-processing)呈现图面之前提高网格属性。</span><span class="sxs-lookup"><span data-stu-id="f9d70-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="f9d70-208">使用图面上观察程序</span><span class="sxs-lookup"><span data-stu-id="f9d70-208">Using The Surface Observer</span></span>

<span data-ttu-id="f9d70-209">空间映射的起始点是图面上观察者。</span><span class="sxs-lookup"><span data-stu-id="f9d70-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="f9d70-210">程序流如下所示：</span><span class="sxs-lookup"><span data-stu-id="f9d70-210">Program flow is as follows:</span></span>
* <span data-ttu-id="f9d70-211">创建图面上观察者对象</span><span class="sxs-lookup"><span data-stu-id="f9d70-211">Create a surface observer object</span></span>
   * <span data-ttu-id="f9d70-212">提供一个或多个空间的卷，来定义应用程序希望接收的数据空间映射的感兴趣的区域。</span><span class="sxs-lookup"><span data-stu-id="f9d70-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="f9d70-213">空间卷是空间的只需定义，如球体或箱子的区域的形状。</span><span class="sxs-lookup"><span data-stu-id="f9d70-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="f9d70-214">使用与世界锁定空间坐标系统的空间的卷来标识物理世界的固定的区域。</span><span class="sxs-lookup"><span data-stu-id="f9d70-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="f9d70-215">使用空间的卷，更新每个帧的正文锁定空间坐标系统，以确定所移动 （但不会不会旋转） 的空间区域与该用户。</span><span class="sxs-lookup"><span data-stu-id="f9d70-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="f9d70-216">可能更高版本在与应用程序或用户更改的状态，随时更改这些空间的卷。</span><span class="sxs-lookup"><span data-stu-id="f9d70-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="f9d70-217">使用轮询或通知来检索有关空间表面的信息</span><span class="sxs-lookup"><span data-stu-id="f9d70-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="f9d70-218">你可以轮询空间图面上的状态图面上观察者在任何时间。</span><span class="sxs-lookup"><span data-stu-id="f9d70-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="f9d70-219">或者，可以注册图面上观察程序的更改图面事件，该事件将在图面空间已更改时通知应用程序。</span><span class="sxs-lookup"><span data-stu-id="f9d70-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="f9d70-220">对于动态空间卷，如视图截锥或正文锁定的卷，应用程序将需要轮询更改的每个帧通过设置感兴趣的区域，然后获取当前集的空间表面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="f9d70-221">对于静态的卷，如 world 锁定多维数据集涵盖单个的空间，可以注册要在该卷内的空间表面可能已更改时得到通知的更改图面事件的应用程序。</span><span class="sxs-lookup"><span data-stu-id="f9d70-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="f9d70-222">进程显示更改</span><span class="sxs-lookup"><span data-stu-id="f9d70-222">Process surfaces changes</span></span>
   * <span data-ttu-id="f9d70-223">循环访问组提供的空间表面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="f9d70-224">对空间表面上的添加、 更改或删除进行分类。</span><span class="sxs-lookup"><span data-stu-id="f9d70-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="f9d70-225">对于每个已添加或更改空间图面上，如果相应提交以接收更新的网格表示级别的详细信息所需的表面的当前状态的异步请求。</span><span class="sxs-lookup"><span data-stu-id="f9d70-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="f9d70-226">处理异步网格请求 （在以下各节中更多详细信息）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="f9d70-227">网格缓存</span><span class="sxs-lookup"><span data-stu-id="f9d70-227">Mesh Caching</span></span>

<span data-ttu-id="f9d70-228">由密集三角形网格表示空间图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="f9d70-229">存储、 呈现和处理这些网格可以消耗大量计算和存储资源。</span><span class="sxs-lookup"><span data-stu-id="f9d70-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="f9d70-230">在这种情况下，每个应用程序应采用网格缓存方案适合其需求，为了最小化用于网格处理和存储的资源。</span><span class="sxs-lookup"><span data-stu-id="f9d70-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="f9d70-231">此方案应确定该网格要保留其放弃，，以及何时更新每个空间面的网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="f9d70-232">许多注意事项讨论了直接将通知你的应用程序应接近网格缓存。</span><span class="sxs-lookup"><span data-stu-id="f9d70-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="f9d70-233">应考虑用户通过环境的移动、 所需的图面，将会观察到不同的图面和时应捕获在环境中的更改。</span><span class="sxs-lookup"><span data-stu-id="f9d70-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="f9d70-234">解释提供的图面上观察者的更改图面事件，缓存逻辑的基本网格时，按如下所示：</span><span class="sxs-lookup"><span data-stu-id="f9d70-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="f9d70-235">如果应用程序发现之前没有见过的空间表面 ID，它应将此视为新的空间图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="f9d70-236">如果应用程序将与已知 ID 的空间表面，但新的更新时间，它应将此视为是更新后的空间表面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="f9d70-237">如果该应用程序不会再看到与已知 ID 的空间表面，它应将此视为已删除的空间图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="f9d70-238">负责每个应用程序，然后进行以下选择：</span><span class="sxs-lookup"><span data-stu-id="f9d70-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="f9d70-239">对于新的空间图面，应请求网格？</span><span class="sxs-lookup"><span data-stu-id="f9d70-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="f9d70-240">通常网格应立即请求对于新的空间图面，可向用户提供有用的新信息。</span><span class="sxs-lookup"><span data-stu-id="f9d70-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="f9d70-241">但是，新的空间表面附近和用户应分配的优先级，应首先请求其网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="f9d70-242">如果不需要新的网格，如果例如应用程序已永久或暂时冻结其环境的模型，然后它应不请求。</span><span class="sxs-lookup"><span data-stu-id="f9d70-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="f9d70-243">应为更新的空间表面，请求网格？</span><span class="sxs-lookup"><span data-stu-id="f9d70-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="f9d70-244">更新的空间表面附近，用户应分配的优先级，应首先请求其网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="f9d70-245">它还需要能够向新的图面，若要更新的图面，尤其是在扫描体验比更高的优先级。</span><span class="sxs-lookup"><span data-stu-id="f9d70-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="f9d70-246">若要限制处理成本，应用程序可能想要限制他们处理到空间表面的更新的速率。</span><span class="sxs-lookup"><span data-stu-id="f9d70-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="f9d70-247">它可能是可能推断出更改到空间面很小的例如，如果面的边界很小，在这种情况下更新可能不重要到进程。</span><span class="sxs-lookup"><span data-stu-id="f9d70-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="f9d70-248">但在这种情况下它可能是更高效，若要修改的图面上观察程序使用的空间边界卷可能完全忽略更新到当前用户的感兴趣的区域之外的空间表面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="f9d70-249">对于已删除的空间图面，应放弃网格？</span><span class="sxs-lookup"><span data-stu-id="f9d70-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="f9d70-250">通常网格应被立即放弃对于已删除的空间图面，以便全息图封闭保持正确。</span><span class="sxs-lookup"><span data-stu-id="f9d70-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="f9d70-251">但是，如果应用程序有理由相信，空间面将稍后重新出现 （可能是根据用户体验的设计），则它可能更有效保留它比放弃其网格并稍后再重新创建它。</span><span class="sxs-lookup"><span data-stu-id="f9d70-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="f9d70-252">如果要构建应用程序的用户环境的大型模型然后它可能不想要完全放弃任何网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="f9d70-253">它将仍需要资源使用情况，可能是通过限制后台处理到磁盘的网格按空间图面消失。</span><span class="sxs-lookup"><span data-stu-id="f9d70-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="f9d70-254">请注意，某些相对较少事件在空间图面上的生成过程中可能会导致空间表面替换为在类似的位置，但具有不同 Id 的新空间图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="f9d70-255">因此，选择不放弃已删除的面上的应用程序应注意不到最终会与多个高度重叠空间图面上的网格覆盖相同的位置。</span><span class="sxs-lookup"><span data-stu-id="f9d70-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="f9d70-256">应为任何其他空间表面放弃网格？</span><span class="sxs-lookup"><span data-stu-id="f9d70-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="f9d70-257">即使空间面存在，如果它不再适用于用户的体验则应放弃。</span><span class="sxs-lookup"><span data-stu-id="f9d70-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="f9d70-258">例如，如果应用程序替换为在门口的另一端房间的备用虚拟空间然后在该空间中的空间表面不再重要。</span><span class="sxs-lookup"><span data-stu-id="f9d70-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="f9d70-259">下面是示例网格缓存策略，使用空间和临时滞后：</span><span class="sxs-lookup"><span data-stu-id="f9d70-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="f9d70-260">请考虑想要使用形截锥空间卷遵循用户的视线移动，如它们一下，然后在不同的感兴趣的应用程序。</span><span class="sxs-lookup"><span data-stu-id="f9d70-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="f9d70-261">空间面可能消失，暂时从该卷只是因为用户从表面看上去或离开它进一步的步骤...仅用于回过头来或越来越接近再次稍后更高版本。</span><span class="sxs-lookup"><span data-stu-id="f9d70-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="f9d70-262">在这种情况下，放弃并重新创建此面的网格表示大量的冗余处理。</span><span class="sxs-lookup"><span data-stu-id="f9d70-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="f9d70-263">若要减少处理更改次数，应用程序，请使用两个空间图面上观察者，其中包含在另一个。</span><span class="sxs-lookup"><span data-stu-id="f9d70-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="f9d70-264">较大的卷是球面的并遵循用户延迟;它仅移动时有必要，以确保其中心内的用户的 2.0 米。</span><span class="sxs-lookup"><span data-stu-id="f9d70-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="f9d70-265">新的和已更新空间表面网格总是处理从较小内部图面上观察程序，但网格被缓存，直到它们会从更大的外部图面上观察者消失。</span><span class="sxs-lookup"><span data-stu-id="f9d70-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="f9d70-266">这样，应用程序，以避免处理由于本地用户移动多个冗余的更改。</span><span class="sxs-lookup"><span data-stu-id="f9d70-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="f9d70-267">由于空间面也可能会消失暂时由于跟踪丢失，该应用程序还会丢弃已删除的空间表面延迟期间跟踪丢失。</span><span class="sxs-lookup"><span data-stu-id="f9d70-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="f9d70-268">一般情况下，应用程序应评估降低的更新处理并增加的内存使用情况以确定其理想的缓存策略之间的权衡。</span><span class="sxs-lookup"><span data-stu-id="f9d70-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="f9d70-269">呈现</span><span class="sxs-lookup"><span data-stu-id="f9d70-269">Rendering</span></span>

<span data-ttu-id="f9d70-270">有三个空间的映射网格往往用于呈现的主要方法：</span><span class="sxs-lookup"><span data-stu-id="f9d70-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="f9d70-271">为图面上的可视化效果</span><span class="sxs-lookup"><span data-stu-id="f9d70-271">For surface visualization</span></span>
   * <span data-ttu-id="f9d70-272">通常它可用于直接可视化空间图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="f9d70-273">例如，强制转换 shadows 从对象到空间图面上可以它们放入全息图面时向用户中提供有帮助的可视反馈。</span><span class="sxs-lookup"><span data-stu-id="f9d70-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="f9d70-274">还需要记住的一点是空间网格是不同的类型的三维艺术家可能创建的网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="f9d70-275">三角形拓扑不会为清理为用户创建拓扑和网格就会遇到[各种错误](spatial-mapping-design.md#what-influences-spatial-mapping-quality)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="f9d70-276">若要创建令人满意 visual 美学，你可能因此想要执行一些[mesh 处理](spatial-mapping.md#mesh-processing)，例如对填充漏洞或平滑的表面法线。</span><span class="sxs-lookup"><span data-stu-id="f9d70-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="f9d70-277">您可能还希望到而不是直接可视化网格拓扑和 normals 在网格上使用为项目艺术家设计纹理着色器。</span><span class="sxs-lookup"><span data-stu-id="f9d70-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="f9d70-278">有关 occluding 全息背后实际的图面</span><span class="sxs-lookup"><span data-stu-id="f9d70-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="f9d70-279">空间表面都可以呈现在仅限深度的阶段中的仅影响[深度缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)不会影响颜色呈现器目标。</span><span class="sxs-lookup"><span data-stu-id="f9d70-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="f9d70-280">这会准备好要遮蔽随后呈现全息背后空间表面的深度缓冲区。</span><span class="sxs-lookup"><span data-stu-id="f9d70-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="f9d70-281">准确封闭的全息增强了意义上说，全息实际并不存在用户的物理空间中。</span><span class="sxs-lookup"><span data-stu-id="f9d70-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="f9d70-282">若要启用深度特点，更新设置将 blend 状态[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)为零的所有颜色呈现器目标。</span><span class="sxs-lookup"><span data-stu-id="f9d70-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="f9d70-283">用于修改全息封闭的像素由实际曲面的外观</span><span class="sxs-lookup"><span data-stu-id="f9d70-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="f9d70-284">当它封闭的像素，隐藏正常呈现的几何图形。</span><span class="sxs-lookup"><span data-stu-id="f9d70-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="f9d70-285">这通过设置深度函数中来实现您[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)为"小于或等于"，这将导致要是可见，仅其中它是几何图形**更接近**到比以前呈现所有相机几何图形。</span><span class="sxs-lookup"><span data-stu-id="f9d70-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="f9d70-286">但是，可能会使某些 geometry 保持可见，即使它封闭的像素，并修改其外观时封闭的像素作为向用户提供可视反馈的一种方法很有用。</span><span class="sxs-lookup"><span data-stu-id="f9d70-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="f9d70-287">例如，这样，应用程序以显示用户的位置的对象，同时使用户清楚地知道，位于实际的图面。</span><span class="sxs-lookup"><span data-stu-id="f9d70-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="f9d70-288">若要实现此目的，请在第二个时间内使用不同的着色器用于创建所需的 occluded 外观呈现 geometry。</span><span class="sxs-lookup"><span data-stu-id="f9d70-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="f9d70-289">第二次呈现几何图形之前, 进行两项更改到您[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="f9d70-290">首先，将深度函数设置为"大于或等于"，以便几何图形会显示仅其所在**进一步**从所有以前呈现 geometry 比照相机。</span><span class="sxs-lookup"><span data-stu-id="f9d70-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="f9d70-291">其次，设置为零，DepthWriteMask，以便不会修改深度缓冲区 (深度缓冲区应继续表示几何图形的深度**最接近**到相机)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="f9d70-292">[性能](understanding-performance-for-mixed-reality.md)呈现空间映射网格时考虑的重要因素。</span><span class="sxs-lookup"><span data-stu-id="f9d70-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="f9d70-293">下面是特定于呈现空间映射网格某些呈现性能技术：</span><span class="sxs-lookup"><span data-stu-id="f9d70-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="f9d70-294">调整三角形密度</span><span class="sxs-lookup"><span data-stu-id="f9d70-294">Adjust triangle density</span></span>
   * <span data-ttu-id="f9d70-295">当请求空间表面网格从你的图面上观察者时，请求可满足你的需求的三角形网格的密度最低。</span><span class="sxs-lookup"><span data-stu-id="f9d70-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="f9d70-296">可能有意义改变三角形密度对于曲面的图面，具体取决于用户，从表面的距离以及与用户体验。</span><span class="sxs-lookup"><span data-stu-id="f9d70-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="f9d70-297">减少三角形计数将减少内存使用情况和在 GPU 上的顶点处理成本，但它不会影响像素处理开销。</span><span class="sxs-lookup"><span data-stu-id="f9d70-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="f9d70-298">执行截锥消除</span><span class="sxs-lookup"><span data-stu-id="f9d70-298">Perform frustum culling</span></span>
   * <span data-ttu-id="f9d70-299">截锥消除跳过当前显示截锥外部，无法查看的图形对象。</span><span class="sxs-lookup"><span data-stu-id="f9d70-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="f9d70-300">这样可以减少 CPU 和 GPU 处理成本。</span><span class="sxs-lookup"><span data-stu-id="f9d70-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="f9d70-301">由于消除在每个网格的基础上执行，并且空间表面可能很大，每个空间的表面网格拆分为较小的区块可能会导致更高效消除 （因为呈现较少屏幕外三角形）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="f9d70-302">然而，进行权衡，你有多个网格、 多个绘图调用，请这样做可以提高 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="f9d70-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="f9d70-303">在极端情况下，消除计算本身截锥甚至可以具有的可测量的 CPU 开销。</span><span class="sxs-lookup"><span data-stu-id="f9d70-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="f9d70-304">调整呈现顺序</span><span class="sxs-lookup"><span data-stu-id="f9d70-304">Adjust rendering order</span></span>
   * <span data-ttu-id="f9d70-305">空间表面往往很大，因为它们代表其周围的用户的整个环境。</span><span class="sxs-lookup"><span data-stu-id="f9d70-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="f9d70-306">像素处理在 GPU 上的成本因此可能很高，尤其是在情况下没有多个层可见的几何图形 （包括空间表面和其他全息）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="f9d70-307">在这种情况下，离用户最近的层将为 occluding 进一步任何层，因此所用任何 GPU 时间呈现更远距离的那些层会浪费。</span><span class="sxs-lookup"><span data-stu-id="f9d70-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="f9d70-308">若要减少在 GPU 上的此多余工作，最好按从前到后顺序呈现不透明的图面 (更接近的第一个、 多远距离的最后一个)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="f9d70-309">不透明是指图面中设置其 DepthWriteMask 你[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)。</span><span class="sxs-lookup"><span data-stu-id="f9d70-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="f9d70-310">最接近的图面呈现时，它们将素数深度缓冲区，以便更远距离的图面有效地跳过像素处理器在 GPU 上。</span><span class="sxs-lookup"><span data-stu-id="f9d70-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="f9d70-311">网格处理</span><span class="sxs-lookup"><span data-stu-id="f9d70-311">Mesh Processing</span></span>

<span data-ttu-id="f9d70-312">应用程序可能想要执行[各种操作](spatial-mapping.md#mesh-processing)上空间图面上的网格来满足其需求。</span><span class="sxs-lookup"><span data-stu-id="f9d70-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="f9d70-313">提供与每个空间的表面网格的索引和顶点数据使用相同的熟悉布局[顶点和索引缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)用于呈现在所有现代呈现 Api 的三角形网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="f9d70-314">但是，一个关键的一点需要注意的是，有空间映射三角形**前端的顺时针缠绕顺序**。</span><span class="sxs-lookup"><span data-stu-id="f9d70-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="f9d70-315">每个三角形由网格的索引缓冲区中的三个顶点索引，并且这些索引将标识中的三角形的顶点**顺时针**顺序，从查看三角形时**前端**端。</span><span class="sxs-lookup"><span data-stu-id="f9d70-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="f9d70-316">前面端 （或外部） 的空间表面网格对应正如您期望前方的现实世界图面 （可见）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="f9d70-317">如果提供的图面上观察者的粗糙三角形密度为仍不足粗略-这项工作的计算成本高昂的网格简化和已完成的运行时生成的不同，才应执行应用程序提供的详细信息级别。</span><span class="sxs-lookup"><span data-stu-id="f9d70-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="f9d70-318">因为每个图面上观察程序可以提供多个未连接的空间表面，某些应用程序可能想要裁剪这些空间表面网格对每个其他，然后拉链它们在一起。</span><span class="sxs-lookup"><span data-stu-id="f9d70-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="f9d70-319">一般情况下，剪辑步骤是必需的如附近的空间表面网格通常会稍微重叠。</span><span class="sxs-lookup"><span data-stu-id="f9d70-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="f9d70-320">光线投射的细节和冲突</span><span class="sxs-lookup"><span data-stu-id="f9d70-320">Raycasting and Collision</span></span>

<span data-ttu-id="f9d70-321">为了使物理引擎 API (如[Havok](http://www.havok.com/)) 若要提供空间表面光线投射的细节和冲突的功能的应用程序，该应用程序必须提供空间表面网格到物理引擎 API。</span><span class="sxs-lookup"><span data-stu-id="f9d70-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="f9d70-322">通常使用物理引擎的网格具有以下属性：</span><span class="sxs-lookup"><span data-stu-id="f9d70-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="f9d70-323">它们只能包含小数字的三角形。</span><span class="sxs-lookup"><span data-stu-id="f9d70-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="f9d70-324">物理操作都是多个计算密集型比呈现操作。</span><span class="sxs-lookup"><span data-stu-id="f9d70-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="f9d70-325">它们是 water 紧密。</span><span class="sxs-lookup"><span data-stu-id="f9d70-325">They are 'water-tight'.</span></span> <span data-ttu-id="f9d70-326">图面旨在为实线不应具有小型洞;甚至过小，不可见的漏洞可能导致问题。</span><span class="sxs-lookup"><span data-stu-id="f9d70-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="f9d70-327">它们会转换为凸 hulls。</span><span class="sxs-lookup"><span data-stu-id="f9d70-327">They are converted into convex hulls.</span></span> <span data-ttu-id="f9d70-328">凸 hulls 具有几个多边形，并且是免费的漏洞，并且它们是计算更有效地处理不是原始的三角形网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="f9d70-329">当执行 raycasts 针对空间图面，请注意，这些图面通常是复杂时, 混乱的形状的杂乱的小细节-只是喜欢办公桌 ！</span><span class="sxs-lookup"><span data-stu-id="f9d70-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="f9d70-330">这意味着单个 raycast 通常是不足为您提供有关形状图面和办公电话附近的空白区域的形状的足够信息。</span><span class="sxs-lookup"><span data-stu-id="f9d70-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="f9d70-331">它是这样通常执行较小区域中的许多 raycasts 以及使用的聚合结果来派生有一个更可靠的图面了解是个好主意。</span><span class="sxs-lookup"><span data-stu-id="f9d70-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="f9d70-332">例如，使用 10 个 raycasts 平均值到图面上的指南全息图放置将产生得更流畅和较低抖动的结果使用只是单个 raycast。</span><span class="sxs-lookup"><span data-stu-id="f9d70-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="f9d70-333">但是，记住每个 raycast 可以具有较高的计算成本。</span><span class="sxs-lookup"><span data-stu-id="f9d70-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="f9d70-334">因此具体取决于你的使用方案，应权衡其他 raycasts 的计算成本 （执行每个帧） 针对的计算成本[mesh 处理](spatial-mapping.md#mesh-processing)平滑和删除空间表面 （中的漏洞执行更新空间网格时）。</span><span class="sxs-lookup"><span data-stu-id="f9d70-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="f9d70-335">疑难解答</span><span class="sxs-lookup"><span data-stu-id="f9d70-335">Troubleshooting</span></span>
* <span data-ttu-id="f9d70-336">为了使图面上的网格，无法正确 orientated，每个 GameObject 需要处于活动状态，它发送到 SurfaceObeserver 能够构造其网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="f9d70-337">否则，网格将显示在奇怪成但旋转空间中。</span><span class="sxs-lookup"><span data-stu-id="f9d70-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="f9d70-338">需要设置为 origin SurfaceObserver 与运行脚本，用于进行通信的 GameObject。</span><span class="sxs-lookup"><span data-stu-id="f9d70-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="f9d70-339">否则，所有创建并发送到 SurfaceObserver 能够构造其网格的 GameObjects 必须等于父游戏对象的偏移量的偏移量。</span><span class="sxs-lookup"><span data-stu-id="f9d70-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="f9d70-340">这可以使多个指标消失这样，就很难调试正在运行的内容显示在网格。</span><span class="sxs-lookup"><span data-stu-id="f9d70-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="f9d70-341">请参阅</span><span class="sxs-lookup"><span data-stu-id="f9d70-341">See also</span></span>
* [<span data-ttu-id="f9d70-342">坐标系统</span><span class="sxs-lookup"><span data-stu-id="f9d70-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="f9d70-343">在 DirectX 空间映射</span><span class="sxs-lookup"><span data-stu-id="f9d70-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="f9d70-344">在 Unity 中的空间映射</span><span class="sxs-lookup"><span data-stu-id="f9d70-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="f9d70-345">空间映射设计</span><span class="sxs-lookup"><span data-stu-id="f9d70-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="f9d70-346">案例研究-通查在现实中的漏洞</span><span class="sxs-lookup"><span data-stu-id="f9d70-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
