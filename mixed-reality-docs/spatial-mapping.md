---
title: 空间映射
description: 空间映射提供了 HoloLens 周围环境中的实际表面的详细表示形式。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射、 HoloLens、 混合的现实、 图面上重新构造、 网格、 sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/12/2019
ms.locfileid: "59593056"
---
# <a name="spatial-mapping"></a>空间映射

空间映射提供了 HoloLens，围绕环境中的实际表面的详细的表示允许开发人员创建令人信服的混合的现实体验。 通过合并虚拟世界与现实世界，应用程序可以使全息看起来真实。 应用程序还可以更自然对齐与用户的期望通过提供熟悉的实际行为和交互。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>设备支持

<table>
<tr>
<th>功能</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens （第 1 代）</a></th><th style="width:150px">HoloLens 2</th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">沉浸式耳机</a></th>
</tr><tr>
<td> 空间映射</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a>概念性概述

![网格图面涵盖聊天室](images/SurfaceReconstruction.jpg)<br>
*举例说明了空间映射网格涵盖聊天室*

用于空间映射的两个主要对象类型是空间面观察者和空间面。

应用程序提供了空间面观察程序提供一个或多个边界卷，若要定义的应用程序希望接收空间映射数据的空间区域。 对于每个这些卷，空间映射将提供一组空间曲面的应用程序。

这些卷可能处于静止状态 （相对于现实世界的固定位置） 或可能将它们附加到 HoloLens （它们移动，但不是会旋转，与 HoloLens 流过环境）。 每个空间的图面描述中表示为附加到世界上锁定三角形网格的空间量很小的实际表面[空间坐标系统](coordinate-systems.md)。

作为 HoloLens 收集新数据有关的环境中，对环境的更改发生时，将出现空间表面，消失，并将更改。

## <a name="common-usage-scenarios"></a>常见使用方案

![空间映射的常见使用方案的说明：放置、 封闭、 物理和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a>放置

空间映射提供了使用可以提供给用户; 简单自然且熟悉的交互的窗体应用程序还有什么能比在办公桌上向下放置你的手机更自然？

约束全息的位置 (或更普遍的情况，任何选择的空间位置) 将位于其图面上提供的自然映射从 3D （点空间） 到 2D （在图面上的点）。 这将减少用户需要提供给应用程序，这样可以使用户的交互更快、 更轻松、 更精确的信息量。 因为距离之外不是我们习惯于以物理方式通信到其他人或计算机，也是如此。 当我们点与我们的手指时，我们指定方向，但不是了的距离。

一个重要的注意事项是，当应用程序来推断方向的距离 (例如通过执行查找最接近用户的视线移动方向 raycast 空间图面)，这必须产生用户是否能够可靠地预测的结果。 否则为该用户将失去其意义上的控件，这很快会令人沮丧。 这将帮助的一种方法是执行多个 raycasts 而不是只需一个。 聚合结果应更流畅和可预测、 不易受到影响从暂时性离群值的结果 （如可能引起大气通过微小的漏洞或达到小段几何图形，它并不知道用户）。 聚合或平滑处理也可以随时间;例如，您可以限制在距离用户改变一张全息图可以最大速度。 只限制最小值和最大距离值还可以帮助，因此要移动的全息图不会不突然消失飞入距离或崩溃恢复到用户的人脸。

应用程序还可以使用的形状和方向的表面指南全息图放置到。 Holographic 椅子不应通过墙壁入侵和应位于刷新与 floor 即使略有不均。 此类功能可能会依赖于物理冲突而不是只是 raycasts，但是类似的问题将应用的使用。 如果正在放置的全息图具有伸出，如椅子上, legs 的许多小多边形它很有用的物理表示形式的多边形扩展到更宽且更流畅的内容，以便他们可更多空间表面，而无需通过滑动截图。

其一种极端情况，用户输入可以简化即可完全和图面空间可用于执行完全自动全息图放置。 例如，应用程序无法将置于全息版的灯开关某处在用户按墙上。 有关可预测性的同一注意事项适用双向此处;如果用户需要控制全息图放置功能，但应用程序不会始终施加全息他们预期 （如果灯开关显示用户无法访问的某个位置） 的位置，这将是令人沮丧的体验。 它实际上可能更糟的是执行自动放置功能，需要用户更正一些时间，比以只需要求用户始终会执行放置本身;因为成功的自动放置*预期*，手动更正让人感觉像负担 ！

另请注意，应用程序的位置很大程度取决于应用程序的使用空间表面的功能[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)。 如果尚未扫描图面，然后它不能用于放置。 它是由应用程序为了明确这给用户，以便他们也可以帮助扫描新的图面或选择新的位置。

向用户的可视反馈是在放置过程中极其重要。 用户需要知道其中全息图是相对于使用最接近的图面[接地效果](spatial-mapping.md#visualization)。 它们应了解其全息图的移动 （例如，由于与另一个邻近的图面发生冲突） 约束的原因。 如果它们不能将一张全息图放在当前的位置，然后可视反馈应使它为什么不清除。 例如，如果用户正尝试放置 holographic couch 停滞一半到墙上插座，然后躺椅后面墙上插座的部分应 pulsate 因为什么而怒气冲冲的颜色。 或反之，如果应用程序在其中用户可以看到实际的图面位置找不到空间图面，然后在应用程序应清楚这。 明显缺少此区域中的接地效果可能会达到此目的。

### <a name="occlusion"></a>封闭

空间映射图面的主要用途之一就是遮蔽全息。 此简单行为全息，帮助创建 visceral 即真正占据的与用户相同的物理空间感知真实性上具有很大的影响。

封闭还向用户; 提供的信息一张全息图看起来封闭的实际的图面，这样该 hologram 世界上的空间位置的其他可视反馈。 相反，封闭可以也有用*隐藏*来自用户的信息; occluding 全息背后墙可以减少视觉混乱中以直观的方式。 若要隐藏或显示一张全息图，用户只是必须移动其头。

此外可以使用封闭来准备对基于熟悉的物理交互; 自然的用户界面的期望如果一张全息图封闭的图面是因为该图面是稳定的因此用户应期待全息图将*发生碰撞*的面上，并通过它不是简单地传递。

有时，封闭全息并不可取。 如果用户需要能够与一张全息图进行交互，然后他们需要能够看到它-即使位于实际的图面。 在这种情况下，它通常有意义时它封闭的像素 （例如，通过减少其亮度） 以不同的方式呈现此类一张全息图。 这样一来，用户将能够直观地找到全息图，但它们仍会知道它位于后面的内容。

### <a name="physics"></a>物理引擎

使用物理模拟是另一种方式在哪些空间映射可用于加强*存在*全息用户的物理空间中。 当我 holographic 橡胶球实际上将关闭我的书桌、 跨 floor 退回并消失在躺椅下时，可能会很为我相信，它是不实际存在。

物理模拟还提供了应用程序使用简单自然且熟悉的物理交互的机会。 将一种围绕 holographic 家具移动的地板上很可能是便于用户如果家具响应就好像它已在使用适当的延时和冲突的下限之间滑动。

为了生成实际的物理行为，可能需要执行一些[mesh 处理](spatial-mapping.md#mesh-processing)填充漏洞，如删除浮动 hallucinations 和平滑的大致图面。

您还需要考虑如何应用程序[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)会影响其物理模拟。 首先，缺少表面不会与任何内容;当关闭走廊和关闭已知世界末日橡胶球滚动关闭时，会发生什么情况？ 其次，您需要决定是否仍将随着时间的推移对环境中的更改作出响应。 在某些情况下，您将希望尽快; 响应假设是否用户使用门和家具作为可移动 barricades 中对传入 Roman 箭头 tempest 的防御。 在其他情况下，你可能想要忽略新的更新;在地板上推动周围赛场你 holographic 跑车突然不可能或宠物狗决定坐在中间跟踪太有趣了。

### <a name="navigation"></a>导航

应用程序可以使用数据空间映射授予 holographic 字符 （或代理） 与真实的人将相同的方式导航现实世界的能力。 这可以帮助加强全息版的存在通过限制对一组相同的自然、 熟悉的用户和他们的朋友的行为。

导航功能可能对用户非常有用。 在给定区域中生成导航图之后, 它无法共享与该位置提供的新用户不熟悉 holographic 方向。 无法设计此映射，以帮助保持显呆板通信非常顺利，或避免事故等建筑工地的危险位置中。

关键的技术挑战参与实现导航功能将是可靠检测到的移动应用层协议 （人类不审核表 ！） 和正常适应 （人类不演练已关闭的大门 ！） 的环境中的更改。 网格可能需要一些[处理](spatial-mapping.md#mesh-processing)是可用于路径规划和导航虚拟字符之前。 平滑处理网格和删除 hallucinations 可能有助于避免成为停滞的字符。 您可能还希望极大地简化为了加快您的人物路径规划和导航计算网格。 这些挑战的视频游戏设备技术开发中收到大量的关注和丰富的发布的调查宣传资料中对这些主题。

请注意在 Unity 中的内置 NavMesh 功能不能用于空间映射图面。 这是因为空间映射图面之前未知的应用程序启动，而需要从提前源资产生成 NavMesh 数据文件。 另请注意，将不会提供空间映射系统[信息非常远面](spatial-mapping-design.md#the-environment-scanning-experience)从用户的当前位置。 使应用程序必须记住图面本身如果它是用于生成非常大的区域的映射。

### <a name="visualization"></a>可视化效果

大多数情况下它是适用于空间表面不可见;最大程度减少视觉混乱，并允许真实世界自己说话。 但是，有时它很直接，尽管它们实际的对应项都已经可见可视化空间映射图面。

例如，当用户正尝试放置到图面 （全息版的 cab 文件上放置墙上插座，说） 上一张全息图可用于接地 hologram 通过在图面进行投影。 这使用户更清楚了解确切物理邻近区域之间全息图和图面。 这也是以可视方式预览更改之前提交给它的用户的更多常规做法的示例。

通过可视化图面，该应用程序可以与用户共享其了解环境。 例如，holographic 棋盘类游戏能够呈现水平的图面，则已标识为表以便让用户知道他们应发送到何处进行交互。

可视化图面可以是有用的方式向用户显示附近的视图中隐藏的空格。 这可能从其起居室提供简单的方法，以允许用户访问其厨房 （和所有其包含全息）。

提供的空间映射图面上网格可能不是特别清理。 因此请务必相应地将其可视化。 传统的照明计算可能会突出显示错误中曲面法线以直观地让人分散注意力的方式，同时投影到图面上的清理纹理可帮助使其整洁的外观。 还有可能执行[mesh 处理](spatial-mapping.md#mesh-processing)呈现图面之前提高网格属性。

## <a name="using-the-surface-observer"></a>使用图面上观察程序

空间映射的起始点是图面上观察者。 程序流如下所示：
* 创建图面上观察者对象
   * 提供一个或多个空间的卷，来定义应用程序希望接收的数据空间映射的感兴趣的区域。 空间卷是空间的只需定义，如球体或箱子的区域的形状。
   * 使用与世界锁定空间坐标系统的空间的卷来标识物理世界的固定的区域。
   * 使用空间的卷，更新每个帧的正文锁定空间坐标系统，以确定所移动 （但不会不会旋转） 的空间区域与该用户。
   * 可能更高版本在与应用程序或用户更改的状态，随时更改这些空间的卷。
* 使用轮询或通知来检索有关空间表面的信息
   * 你可以轮询空间图面上的状态图面上观察者在任何时间。 或者，可以注册图面上观察程序的更改图面事件，该事件将在图面空间已更改时通知应用程序。
   * 对于动态空间卷，如视图截锥或正文锁定的卷，应用程序将需要轮询更改的每个帧通过设置感兴趣的区域，然后获取当前集的空间表面。
   * 对于静态的卷，如 world 锁定多维数据集涵盖单个的空间，可以注册要在该卷内的空间表面可能已更改时得到通知的更改图面事件的应用程序。
* 进程显示更改
   * 循环访问组提供的空间表面。
   * 对空间表面上的添加、 更改或删除进行分类。
   * 对于每个已添加或更改空间图面上，如果相应提交以接收更新的网格表示级别的详细信息所需的表面的当前状态的异步请求。
* 处理异步网格请求 （在以下各节中更多详细信息）。

## <a name="mesh-caching"></a>网格缓存

由密集三角形网格表示空间图面。 存储、 呈现和处理这些网格可以消耗大量计算和存储资源。 在这种情况下，每个应用程序应采用网格缓存方案适合其需求，为了最小化用于网格处理和存储的资源。 此方案应确定该网格要保留其放弃，，以及何时更新每个空间面的网格。

许多注意事项讨论了直接将通知你的应用程序应接近网格缓存。 应考虑用户通过环境的移动、 所需的图面，将会观察到不同的图面和时应捕获在环境中的更改。

解释提供的图面上观察者的更改图面事件，缓存逻辑的基本网格时，按如下所示：
* 如果应用程序发现之前没有见过的空间表面 ID，它应将此视为新的空间图面。
* 如果应用程序将与已知 ID 的空间表面，但新的更新时间，它应将此视为是更新后的空间表面。
* 如果该应用程序不会再看到与已知 ID 的空间表面，它应将此视为已删除的空间图面。

负责每个应用程序，然后进行以下选择：
* 对于新的空间图面，应请求网格？
   * 通常网格应立即请求对于新的空间图面，可向用户提供有用的新信息。
   * 但是，新的空间表面附近和用户应分配的优先级，应首先请求其网格。
   * 如果不需要新的网格，如果例如应用程序已永久或暂时冻结其环境的模型，然后它应不请求。
* 应为更新的空间表面，请求网格？
   * 更新的空间表面附近，用户应分配的优先级，应首先请求其网格。
   * 它还需要能够向新的图面，若要更新的图面，尤其是在扫描体验比更高的优先级。
   * 若要限制处理成本，应用程序可能想要限制他们处理到空间表面的更新的速率。
   * 它可能是可能推断出更改到空间面很小的例如，如果面的边界很小，在这种情况下更新可能不重要到进程。
   * 但在这种情况下它可能是更高效，若要修改的图面上观察程序使用的空间边界卷可能完全忽略更新到当前用户的感兴趣的区域之外的空间表面。
* 对于已删除的空间图面，应放弃网格？
   * 通常网格应被立即放弃对于已删除的空间图面，以便全息图封闭保持正确。
   * 但是，如果应用程序有理由相信，空间面将稍后重新出现 （可能是根据用户体验的设计），则它可能更有效保留它比放弃其网格并稍后再重新创建它。
   * 如果要构建应用程序的用户环境的大型模型然后它可能不想要完全放弃任何网格。 它将仍需要资源使用情况，可能是通过限制后台处理到磁盘的网格按空间图面消失。
   * 请注意，某些相对较少事件在空间图面上的生成过程中可能会导致空间表面替换为在类似的位置，但具有不同 Id 的新空间图面。 因此，选择不放弃已删除的面上的应用程序应注意不到最终会与多个高度重叠空间图面上的网格覆盖相同的位置。
* 应为任何其他空间表面放弃网格？
   * 即使空间面存在，如果它不再适用于用户的体验则应放弃。 例如，如果应用程序替换为在门口的另一端房间的备用虚拟空间然后在该空间中的空间表面不再重要。

下面是示例网格缓存策略，使用空间和临时滞后：
* 请考虑想要使用形截锥空间卷遵循用户的视线移动，如它们一下，然后在不同的感兴趣的应用程序。
* 空间面可能消失，暂时从该卷只是因为用户从表面看上去或离开它进一步的步骤...仅用于回过头来或越来越接近再次稍后更高版本。 在这种情况下，放弃并重新创建此面的网格表示大量的冗余处理。
* 若要减少处理更改次数，应用程序，请使用两个空间图面上观察者，其中包含在另一个。 较大的卷是球面的并遵循用户延迟;它仅移动时有必要，以确保其中心内的用户的 2.0 米。
* 新的和已更新空间表面网格总是处理从较小内部图面上观察程序，但网格被缓存，直到它们会从更大的外部图面上观察者消失。 这样，应用程序，以避免处理由于本地用户移动多个冗余的更改。
* 由于空间面也可能会消失暂时由于跟踪丢失，该应用程序还会丢弃已删除的空间表面延迟期间跟踪丢失。
* 一般情况下，应用程序应评估降低的更新处理并增加的内存使用情况以确定其理想的缓存策略之间的权衡。

## <a name="rendering"></a>呈现

有三个空间的映射网格往往用于呈现的主要方法：
* 为图面上的可视化效果
   * 通常它可用于直接可视化空间图面。 例如，强制转换 shadows 从对象到空间图面上可以它们放入全息图面时向用户中提供有帮助的可视反馈。
   * 还需要记住的一点是空间网格是不同的类型的三维艺术家可能创建的网格。 三角形拓扑不会为清理为用户创建拓扑和网格就会遇到[各种错误](spatial-mapping-design.md#what-influences-spatial-mapping-quality)。
   * 若要创建令人满意 visual 美学，你可能因此想要执行一些[mesh 处理](spatial-mapping.md#mesh-processing)，例如对填充漏洞或平滑的表面法线。 您可能还希望到而不是直接可视化网格拓扑和 normals 在网格上使用为项目艺术家设计纹理着色器。
* 有关 occluding 全息背后实际的图面
   * 空间表面都可以呈现在仅限深度的阶段中的仅影响[深度缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)不会影响颜色呈现器目标。
   * 这会准备好要遮蔽随后呈现全息背后空间表面的深度缓冲区。 准确封闭的全息增强了意义上说，全息实际并不存在用户的物理空间中。
   * 若要启用深度特点，更新设置将 blend 状态[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)为零的所有颜色呈现器目标。
* 用于修改全息封闭的像素由实际曲面的外观
   * 当它封闭的像素，隐藏正常呈现的几何图形。 这通过设置深度函数中来实现您[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)为"小于或等于"，这将导致要是可见，仅其中它是几何图形**更接近**到比以前呈现所有相机几何图形。
   * 但是，可能会使某些 geometry 保持可见，即使它封闭的像素，并修改其外观时封闭的像素作为向用户提供可视反馈的一种方法很有用。 例如，这样，应用程序以显示用户的位置的对象，同时使用户清楚地知道，位于实际的图面。
   * 若要实现此目的，请在第二个时间内使用不同的着色器用于创建所需的 occluded 外观呈现 geometry。 第二次呈现几何图形之前, 进行两项更改到您[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)。 首先，将深度函数设置为"大于或等于"，以便几何图形会显示仅其所在**进一步**从所有以前呈现 geometry 比照相机。 其次，设置为零，DepthWriteMask，以便不会修改深度缓冲区 (深度缓冲区应继续表示几何图形的深度**最接近**到相机)。

[性能](understanding-performance-for-mixed-reality.md)呈现空间映射网格时考虑的重要因素。 下面是特定于呈现空间映射网格某些呈现性能技术：
* 调整三角形密度
   * 当请求空间表面网格从你的图面上观察者时，请求可满足你的需求的三角形网格的密度最低。
   * 可能有意义改变三角形密度对于曲面的图面，具体取决于用户，从表面的距离以及与用户体验。
   * 减少三角形计数将减少内存使用情况和在 GPU 上的顶点处理成本，但它不会影响像素处理开销。
* 执行截锥消除
   * 截锥消除跳过当前显示截锥外部，无法查看的图形对象。 这样可以减少 CPU 和 GPU 处理成本。
   * 由于消除在每个网格的基础上执行，并且空间表面可能很大，每个空间的表面网格拆分为较小的区块可能会导致更高效消除 （因为呈现较少屏幕外三角形）。 然而，进行权衡，你有多个网格、 多个绘图调用，请这样做可以提高 CPU 成本。 在极端情况下，消除计算本身截锥甚至可以具有的可测量的 CPU 开销。
* 调整呈现顺序
   * 空间表面往往很大，因为它们代表其周围的用户的整个环境。 像素处理在 GPU 上的成本因此可能很高，尤其是在情况下没有多个层可见的几何图形 （包括空间表面和其他全息）。 在这种情况下，离用户最近的层将为 occluding 进一步任何层，因此所用任何 GPU 时间呈现更远距离的那些层会浪费。
   * 若要减少在 GPU 上的此多余工作，最好按从前到后顺序呈现不透明的图面 (更接近的第一个、 多远距离的最后一个)。 不透明是指图面中设置其 DepthWriteMask 你[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)。 最接近的图面呈现时，它们将素数深度缓冲区，以便更远距离的图面有效地跳过像素处理器在 GPU 上。

## <a name="mesh-processing"></a>网格处理

应用程序可能想要执行[各种操作](spatial-mapping.md#mesh-processing)上空间图面上的网格来满足其需求。 提供与每个空间的表面网格的索引和顶点数据使用相同的熟悉布局[顶点和索引缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)用于呈现在所有现代呈现 Api 的三角形网格。 但是，一个关键的一点需要注意的是，有空间映射三角形**前端的顺时针缠绕顺序**。 每个三角形由网格的索引缓冲区中的三个顶点索引，并且这些索引将标识中的三角形的顶点**顺时针**顺序，从查看三角形时**前端**端。 前面端 （或外部） 的空间表面网格对应正如您期望前方的现实世界图面 （可见）。

如果提供的图面上观察者的粗糙三角形密度为仍不足粗略-这项工作的计算成本高昂的网格简化和已完成的运行时生成的不同，才应执行应用程序提供的详细信息级别。

因为每个图面上观察程序可以提供多个未连接的空间表面，某些应用程序可能想要裁剪这些空间表面网格对每个其他，然后拉链它们在一起。 一般情况下，剪辑步骤是必需的如附近的空间表面网格通常会稍微重叠。

## <a name="raycasting-and-collision"></a>光线投射的细节和冲突

为了使物理引擎 API (如[Havok](http://www.havok.com/)) 若要提供空间表面光线投射的细节和冲突的功能的应用程序，该应用程序必须提供空间表面网格到物理引擎 API。 通常使用物理引擎的网格具有以下属性：
* 它们只能包含小数字的三角形。 物理操作都是多个计算密集型比呈现操作。
* 它们是 water 紧密。 图面旨在为实线不应具有小型洞;甚至过小，不可见的漏洞可能导致问题。
* 它们会转换为凸 hulls。 凸 hulls 具有几个多边形，并且是免费的漏洞，并且它们是计算更有效地处理不是原始的三角形网格。

当执行 raycasts 针对空间图面，请注意，这些图面通常是复杂时, 混乱的形状的杂乱的小细节-只是喜欢办公桌 ！ 这意味着单个 raycast 通常是不足为您提供有关形状图面和办公电话附近的空白区域的形状的足够信息。 它是这样通常执行较小区域中的许多 raycasts 以及使用的聚合结果来派生有一个更可靠的图面了解是个好主意。 例如，使用 10 个 raycasts 平均值到图面上的指南全息图放置将产生得更流畅和较低抖动的结果使用只是单个 raycast。

但是，记住每个 raycast 可以具有较高的计算成本。 因此具体取决于你的使用方案，应权衡其他 raycasts 的计算成本 （执行每个帧） 针对的计算成本[mesh 处理](spatial-mapping.md#mesh-processing)平滑和删除空间表面 （中的漏洞执行更新空间网格时）。

## <a name="troubleshooting"></a>疑难解答
* 为了使图面上的网格，无法正确 orientated，每个 GameObject 需要处于活动状态，它发送到 SurfaceObeserver 能够构造其网格。 否则，网格将显示在奇怪成但旋转空间中。
* 需要设置为 origin SurfaceObserver 与运行脚本，用于进行通信的 GameObject。 否则，所有创建并发送到 SurfaceObserver 能够构造其网格的 GameObjects 必须等于父游戏对象的偏移量的偏移量。 这可以使多个指标消失这样，就很难调试正在运行的内容显示在网格。

## <a name="see-also"></a>请参阅
* [坐标系统](coordinate-systems.md)
* [在 DirectX 空间映射](spatial-mapping-in-directx.md)
* [在 Unity 中的空间映射](spatial-mapping-in-unity.md)
* [空间映射设计](spatial-mapping-design.md)
* [案例研究-通查在现实中的漏洞](case-study-looking-through-holes-in-your-reality.md)
