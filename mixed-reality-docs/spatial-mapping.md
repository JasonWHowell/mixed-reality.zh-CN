---
title: 空间映射
description: 空间映射提供了在 HoloLens 环境中实际表面的详细表示。
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 空间映射, HoloLens, 混合现实, 表面重建, 网格, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/24/2019
ms.locfileid: "63550489"
---
# <a name="spatial-mapping"></a>空间映射

空间映射提供了针对 HoloLens 环境中实际表面表面的详细表示, 使开发人员能够创建一个具有说服力混合的现实体验。 通过将现实世界与虚拟世界合并, 应用程序可以使全息影像看起来非常真实。 应用程序通过提供熟悉的实际行为和交互, 还可以更自然地与用户的预期保持一致。

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>设备支持

<table>
<tr>
<th>功能</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens（第一代）</a></th><th style="width:150px">HoloLens 2</th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">沉浸式头戴显示设备</a></th>
</tr><tr>
<td> 空间映射</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a>概念性概述

![覆盖房间的网格面](images/SurfaceReconstruction.jpg)<br>
*覆盖房间的空间映射网格示例*

用于空间映射的两个主要对象类型为 "空间图观察器" 和 "空间图面"。

应用程序为空间图面观察器提供一个或多个边界卷, 以定义应用程序希望接收空间映射数据的空间区域。 对于每个卷, 空间映射将为应用程序提供一组空间图面。

这些卷可能是固定的 (在固定位置与现实世界相关), 也可能附加到 HoloLens (它们在环境中移动时不会进行旋转)。 每个空间图面都描述了小空间中的实际表面, 表示为附加到世界锁定的[空间坐标系统](coordinate-systems.md)的三角形网格。

当 HoloLens 收集有关环境的新数据时, 如果对环境进行了更改, 空间图面将显示、消失和变化。

## <a name="common-usage-scenarios"></a>常见使用方案

![常见空间映射使用方案的插图:放置、封闭、物理学和导航](images/sm-concepts-1000px.png)

### <a name="placement"></a>放置

空间映射为应用程序提供了向用户提供自然和熟悉的交互形式的机会。比将电话向下移动电话的情况如何？

将全息图 (或更常见的空间位置选项) 的位置约束为在表面上提供从 3D (点到空间) 到 2D (点上点) 的自然映射。 这会减少用户提供给应用程序所需的信息量, 进而使用户的交互速度更快、更简单且更精确。 这种情况特别适用, 因为 "距离远离" 不是我们用于与其他人或计算机进行物理通信的内容。 当我们使用手指点时, 我们指定的是一个方向, 而不是距离。

此处需要注意的一个重要事项是, 当应用程序推断方向的距离 (例如, 沿用户的注视方向执行 raycast 以查找最接近的空间图面) 时, 这必须生成用户能够可靠预测的结果。 否则, 用户将失去控制, 这很快就会变得沮丧。 有助于实现此功能的一种方法是执行多个 raycasts, 而不是只执行一个。 聚合结果应更平滑且更具可预测性, 不会影响暂时性的 "离群" 结果 (这可能是由于光线通过小孔而导致用户不知道的少量几何) 引起的。 还可以在一段时间内执行聚合或平滑处理;例如, 可以限制每个用户与用户之间的距离变化的最大速度。 只是限制最小值和最大距离值也很有帮助, 因此, 要移动的全息影像不会突然飞入到远处, 也不会发生故障。

应用程序还可以使用图面的形状和方向来指导全息图放置。 全息椅子不应穿透墙壁, 并应与地面齐平, 即使它略有变化。 这种功能可能会依赖于使用物理学冲突而不只是 raycasts, 但会应用类似的问题。 如果放置的全息图包含许多小多边形, 如椅子上的支线, 则将这些多边形的物理表示形式扩大到更宽和更平滑的位置, 使其更能在不适合.

在其极端情况下, 用户输入可以完全被简化, 空间表面可用于执行完全自动的全息影像放置。 例如, 应用程序可能会在墙壁的某个位置放置一个全息片开关, 以便用户按下。 与可预测性相同的注意事项也适用于:如果用户期望控制全息图放置, 但是应用程序并不总是在其预期位置放置全息影像 (如果光交换机出现在用户无法访问的某个位置), 那么这将是一项令人沮丧的体验。 它实际上可能更糟地执行需要用户更正的自动放置, 而不是只要求用户始终执行放置;由于*预期*的自动放置成功, 手动更正就像是一种负担!

另请注意, 应用程序使用空间表面进行放置的能力很大程度上取决于应用程序的[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)。 如果尚未扫描图面, 则它不能用于放置。 这是由应用程序为用户提供的, 因此, 他们可以帮助扫描新的表面或选择新的位置。

在放置过程中, 对用户的视觉反馈非常重要。 用户需要知道全息图与最接近的图面之间的关系, 并具有[接地效果](spatial-mapping.md#visualization)。 它们应了解为什么会限制其全息影像的移动 (例如, 由于与另一个附近表面发生冲突)。 如果它们无法在当前位置放置全息影像, 则视觉对象反馈应清楚地说明为什么不这样做。 例如, 如果用户尝试将全息的沙发卡在墙壁上, 则墙后的沙发部分应 pulsate 为生气的颜色,。 相反地, 如果应用程序在用户可以看到真实表面的位置找不到空间图面, 则应用程序应如此清晰。 此区域中明显不会产生接地效果的情况。

### <a name="occlusion"></a>封闭

空间映射图面的主要用途之一就是遮蔽全息影像。 这一简单的行为对全息影像的明显影响非常大, 有助于创建 visceral 的意义, 真正与用户具有相同的物理空间。

封闭还向用户提供信息;当真实的图面看不封闭像素全息图时, 这将向世界上该全息图的空间位置提供更多的视觉反馈。 相反, 封闭也可以有用*隐藏*用户的信息;occluding 的后台影像可以以直观的方式减少视觉干扰。 若要隐藏或显示全息图, 用户只需移动其头。

封闭还可用于根据熟悉的物理交互, 为自然用户界面提供合理的预期。如果某个图面的封闭像素是一个全息图, 就是因为该表面是稳定的, 因此用户应该认为这种影像将与该表面发生*冲突*, 而不只是通过它。

有时, 不需要封闭的全息影像。 如果用户需要能够与全息图交互, 则他们需要能够看到它, 即使它位于实际的表面上。 在这种情况下, 在封闭像素时 (例如, 通过降低亮度) 呈现此类全息图通常是有意义的。 这样一来, 用户将能够以可视方式找到全息图, 但仍会注意到它位于某个地方。

### <a name="physics"></a>物理

使用物理学模拟的另一种方法是使用空间映射来强化用户物理空间中*是否存在*全息影像。 当我的全息橡胶球从真实上掷走, 弹跳在床上并消失后, 我很难相信它并不真正。

物理学模拟还为应用程序提供了使用自然和熟悉的基于物理学的交互的机会。 如果家具的响应方式与在楼层间滑动, 并具有适当的惯性和摩擦, 则用户可能会更容易地在地面上移动一张全息的家具。

为了生成真实的物理行为, 你可能需要执行一些[网格处理](spatial-mapping.md#mesh-processing), 如填充孔、删除浮动 hallucinations 和平滑表面。

还需要考虑应用程序的[扫描体验](spatial-mapping-design.md#the-environment-scanning-experience)如何影响其物理模拟。 首先, 缺少的图面不会与任何内容发生冲突;当橡胶球向下 corridor 并从已知世界结束时, 会发生什么情况呢？ 其次, 您需要确定是否将在一段时间内继续对环境中的更改做出响应。 在某些情况下, 你需要尽快做出响应;例如, 如果用户使用门和家具作为 barricades 中的可移动的 tempest, 则不会出现传入罗马字箭头的。 但在其他情况下, 你可能想要忽略新的更新;如果狗决定坐在轨迹的中间, 则围绕地面的 racetrack 推动您的全息运动汽车就会突然不那么有趣。

### <a name="navigation"></a>导航

应用程序可以使用空间映射数据来向全息人物 (或代理) 授予在真实情况上以相同方式浏览现实世界的能力。 这可以通过将其限制为用户及其好友的一组自然、熟悉的行为来帮助强化是否存在全息字符。

导航功能对于用户也很有用。 在给定区域中生成导航地图后, 可以将其共享, 为不熟悉该位置的新用户提供全息说明。 此映射可用于帮助保持行人的流量顺畅地流动, 或避免在危险位置 (如构造站点) 中发生意外。

实现导航功能所涉及的关键技术挑战将是对不可图面 (人不对表格进行浏览!) 和正常调整以实现环境中的更改 (人类不会经历闭合的门!)。 网格可能需要进行一些[处理](spatial-mapping.md#mesh-processing)才能用于通过虚拟字符进行路径规划和导航。 平滑网格和删除 hallucinations 可帮助避免字符停滞。 您还可能希望大幅简化网格, 以加快字符的路径规划和导航计算速度。 在开发 videogame 技术时, 这些挑战已经获得了很大的关注, 其中提供了大量有关这些主题的信息。

请注意, Unity 中的内置 NavMesh 功能不能与空间映射图面一起使用。 这是因为在应用程序启动之前空间映射表面是未知的, 而需要提前从源资产生成 NavMesh 数据文件。 另请注意, 空间映射系统不会提供与用户当前位置[有关的有关表面的信息](spatial-mapping-design.md#the-environment-scanning-experience)。 因此, 如果应用程序要生成非常大的区域的地图, 则必须 "记住" 自己的图面。

### <a name="visualization"></a>视觉

大多数情况都适用于空间图面不可见;为了最大程度地减少视觉干扰, 并让现实世界亲自讲述。 但是, 有时可以直接直观显示空间图图面, 尽管它们的实际对应项已经可见。

例如, 当用户尝试将一个全息图放到图面上 (例如, 将一个全息文件柜置于墙壁上时), 通过将阴影转换到图面上来 "地面" 就很有用。 这样, 用户就可以更清楚地了解全息图和表面之间的确切物理距离。 这也是在用户提交到用户之前, 直观地预览更改的更通用的示例。

通过可视化图面, 应用程序可以与用户共享其环境的了解。 例如, 全息板游戏可能会将其标识为 "表" 的水平表面可视化, 因此用户知道应该在何处交互。

可视化图面可用于向用户显示在视图中隐藏的附近的用户。 这可能会提供一种简单的方法, 使用户能够从生活空间访问其厨房 (及其包含的所有全息影像)。

空间映射提供的 surface 网格可能不是特别 "干净的"。 因此, 对其进行适当的可视化非常重要。 传统的照明计算可能会以视觉上分散的方式突出显示曲面法线中的错误, 而投影到表面的 "干净" 纹理可能有助于使其成为整齐的外观。 在呈现表面之前, 还可以执行[网格处理](spatial-mapping.md#mesh-processing)来改善网格属性。

## <a name="using-the-surface-observer"></a>使用 Surface 观察器

空间映射的起始点为 surface 观察程序。 程序流如下所示:
* 创建 surface 观察器对象
   * 提供一个或多个空间卷, 以定义应用程序希望接收空间映射数据的感兴趣的区域。 空间量只是定义空间区域的形状, 例如球或 box。
   * 使用带有世界锁定的空间坐标系统的空间量来识别物理世界的固定区域。
   * 使用空间量, 使用正文锁定的空间坐标系统更新每个帧, 以标识与用户移动 (但不能旋转) 的空间区域。
   * 以后可以随时更改这些空间卷, 因为应用程序或用户的状态会发生更改。
* 使用轮询或通知来检索有关空间图面的信息
   * 您可以随时 "轮询" 面观察器来实现空间图面状态。 或者, 你可以为 surface 观察器的 "surface changed" 事件注册, 这会在空间表面发生更改时通知应用程序。
   * 对于动态空间量 (如视图截锥或正文锁定卷), 应用程序需要通过设置感兴趣的区域, 然后获取当前的空间图面集来轮询每个帧的更改。
   * 对于静态卷 (如涵盖单个房间的全球锁定的多维数据集), 应用程序可能会注册 "已更改" 事件, 以便在该卷内的空间表面发生变化时得到通知。
* 处理表面更改
   * 循环访问提供的空间图面集。
   * 按添加、更改或删除的方式对空间图面进行分类。
   * 对于每个已添加或已更改的空间图面, 如果适当, 请提交一个异步请求, 以在所需的详细信息级别接收表示该图面的当前状态的已更新网格。
* 处理异步网格请求 (以下部分中的详细信息)。

## <a name="mesh-caching"></a>网格缓存

空间图面由密集三角形网格表示。 存储、呈现和处理这些网格可能会占用大量计算和存储资源。 因此, 每个应用程序应采用适合于其需要的网格缓存方案, 以最大程度地减少用于网格处理和存储的资源。 此方案应该确定要保留哪些网格以及要丢弃哪些网格, 以及何时更新每个空间图面的网格。

其中所述的许多注意事项将直接通知您的应用程序应该如何处理网格缓存。 当观察到不同的表面以及应捕获环境中的更改时, 您应考虑用户在环境中的移动方式、需要的表面。

当解释 surface 观察器提供的 "表面变化" 事件时, 基本网格缓存逻辑如下所示:
* 如果应用程序看到之前未出现过的空间表面 ID, 则它应将其视为新的空间图面。
* 如果应用程序看到具有已知 ID 但具有新更新时间的空间图面, 则它应将其视为更新的空间图面。
* 如果应用程序不再看到具有已知 ID 的空间图面, 则它应将其视为已删除的空间图面。

在每个应用程序中, 然后进行以下选择:
* 对于新空间图面, 是否应请求网格？
   * 通常应立即为新的空间图面请求网格, 这可能会向用户提供有用的新信息。
   * 但是, 在用户面前附近和之前的新空间图面应优先, 并首先请求其网格。
   * 如果不需要新网格, 则为; 例如, 如果应用程序永久或临时 "冻结" 其环境模型, 则不应请求它。
* 对于已更新的空间图面, 是否应请求网格？
   * 应将已更新的空间图面置于用户面前, 并应首先请求其网格。
   * 对于新曲面, 更高优先级的优先级可能更高, 特别是在扫描体验过程中。
   * 为了限制处理成本, 应用程序可能希望限制它们处理空间图面更新的速率。
   * 可以推断出对空间图面所做的更改很小, 例如, 如果图面的边界很小, 则更新可能不太重要, 无法处理。
   * 对于用户感兴趣的当前区域之外的空间表面的更新, 可能会完全忽略, 但是在这种情况下, 修改 surface 观察器使用的空间边界卷可能更有效。
* 对于删除的空间表面, 是否应丢弃网格？
   * 通常应为删除的空间图面立即丢弃网格, 使全息图封闭保持正确。
   * 但是, 如果应用程序有理由相信某个空间图面很快就会重新出现 (或许基于用户体验的设计), 则保留它比丢弃其网格并在以后重新创建它更有效。
   * 如果应用程序正在生成用户环境的大规模模型, 则可能不希望全部丢弃任何网格。 不过, 它仍需要限制资源使用情况, 可能通过将网格后台打印到磁盘, 因为空间图面消失。
   * 请注意, 在空间表面生成过程中, 某些相对罕见的事件可能会导致空间图面替换为类似位置但 Id 不同的新空间图面。 因此, 选择不放弃已移除表面的应用程序应注意不会有多个高度重叠的空间表面网格覆盖同一位置。
* 是否应为任何其他空间图面丢弃网格？
   * 即使存在空间图面, 如果它对用户体验不再有用, 则应将其丢弃。 例如, 如果应用程序 "将门口的另一侧的空间替换为备用虚拟空间, 则该房间中的空间表面将不再重要。

下面是使用空间和时态滞后的示例网状缓存策略:
* 假设有一个应用程序, 该应用程序想要在观看和四处浏览时使用在用户的 "注视" 周围的 "截锥" 空间量。
* 空间表面可能会暂时从此卷中消失, 这只是因为用户看起来远离图面或其他步骤 ... 仅供稍后再次查找或更近一段时间。 在这种情况下, 放弃并重新创建此图面的网格表示大量冗余处理。
* 为了减少处理的更改的数量, 应用程序将使用两个空间图面观察器, 其中一个包含在另一个中。 较大的卷为球状, 并跟随用户 "延迟";它仅在必要时才会移动, 以确保其中心在用户的 2.0 metres 范围内。
* 新的和更新的空间 surface 网格始终从较小的内部面观察程序进行处理, 但会缓存网格, 直到它们从较大的外部表面观察器消失。 这使应用程序可以避免因本地用户移动而处理许多冗余更改。
* 由于由于跟踪丢失, 空间图面也可能暂时消失, 因此, 应用程序也会在跟踪丢失期间放弃删除的空间图面。
* 通常情况下, 应用程序应评估减少的更新处理和增加的内存使用情况之间的折衷, 以确定其理想的缓存策略。

## <a name="rendering"></a>渲染

空间映射网格通常用于呈现的主要方式有三种:
* 用于表面可视化
   * 它通常有助于直接可视化空间图面。 例如, 将 "shadows" 从对象强制转换为空间图面时, 可以向用户提供更好的视觉反馈。
   * 需要注意的一点是, 空间网格不同于三维艺术家可能创建的网格类型。 三角形拓扑不会作为用户创建的拓扑 "干净", 并且网格会受到[各种错误](spatial-mapping-design.md#what-influences-spatial-mapping-quality)的影响。
   * 为了创建令人满意的视觉对象美观, 可能需要执行一些[网格处理](spatial-mapping.md#mesh-processing), 例如填充孔或平滑曲面法。 您还可能希望使用着色器将艺术家设计的纹理投影到网格上, 而不是直接可视化网格拓扑和法线。
* 对于真实的图面后面的 occluding 全息影像
   * 空间图面可以在仅深度传递中呈现, 这只会影响[深度缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx)并且不会影响颜色呈现器目标。
   * 这会 primes 深度缓冲区以遮蔽随后呈现的空间表面上呈现的全息影像。 最准确的全息影像封闭增强了全息影像在用户的物理空间内确实存在的意义。
   * 若要启用仅深度渲染, 请更新混合状态, 将所有颜色渲染目标的[RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx)设置为零。
* 用于修改真实环境中全息图封闭像素的外观
   * 当封闭像素时, 通常会隐藏呈现的几何图形。 这是通过将[深度-模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中的深度函数设置为 "小于或等于" 来实现的, 这会使几何仅在**离相机更近**的位置 (而不是所有先前呈现的几何图形) 可见。
   * 但是, 即使在封闭像素时仍可查看某些几何, 并在封闭像素作为向用户提供视觉反馈的方式时修改其外观, 这可能会很有用。 例如, 这允许应用程序向用户显示对象的位置, 同时使其清楚地显示在实际表面。
   * 若要实现此目的, 请使用另一个创建所需 "封闭像素" 外观的着色器第二次渲染几何。 在第二次渲染几何之前, 对[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)进行两次更改。 首先, 将 "深度函数" 设置为 "大于或等于", 以便仅在其从相机中的**其他**位置 (而不是所有先前呈现的几何图形) 中可见。 其次, 将 DepthWriteMask 设置为零, 以便不会修改深度缓冲区 (深度缓冲区应继续表示**距离相机最近**的几何图形的深度)。

在呈现空间映射网格时,[性能](understanding-performance-for-mixed-reality.md)是一个重要的考虑因素。 下面是一些特定于呈现空间映射网格的呈现性能技巧:
* 调整三角形密度
   * 从 surface 观察者请求空间表面网格时, 请求可满足您需求的最小的三角形网格密度。
   * 在图面上改变三角密度可能有意义, 具体取决于表面与用户的距离以及与用户体验的相关性。
   * 减少三角形计数将减少 GPU 上的内存使用量和顶点处理开销, 但它不会影响像素处理开销。
* 执行截锥剔除
   * 截锥剔除会跳过无法看见的绘图对象, 因为它们在当前显示的 "截锥" 之外。 这同时降低了 CPU 和 GPU 处理成本。
   * 由于剔除是根据每个网格进行的, 空间表面可能会很大, 因此, 将每个空间曲面网格分解为较小的区块可能会导致更有效的剔除 (在这种情况下, 将呈现更少的屏幕外三角形)。 不过, 有一种折衷:您拥有的网格越多, 您必须进行的绘图调用越多, 这会增加 CPU 开销。 在极端情况下, 如截锥剔除计算, 甚至可能有可度量的 CPU 开销。
* 调整呈现顺序
   * 空间表面很大, 因为它们代表用户在周围的整个环境。 因此, GPU 上的像素处理开销可能很高, 尤其是在有多个可见几何层 (包括空间表面和其他全息影像) 的情况下。 在这种情况下, 离用户最近的层会进一步 occluding 任何层, 因此, 在呈现这些更远距离的层所用的任何 GPU 时间都将浪费下来。
   * 若要减少 GPU 上的这一冗余工作, 这有助于以从前到后的顺序呈现不透明的图面 (首先是更接近的图面)。 "不透明" 是指在您的[深度模具状态](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)中将 DepthWriteMask 设置为一个的表面。 当呈现最近的图面时, 它们将成为深度缓冲区的质数, 以便 GPU 上的像素处理器有效地跳过更远的图面。

## <a name="mesh-processing"></a>网格处理

应用程序可能希望对空间 surface 网格执行[各种操作](spatial-mapping.md#mesh-processing)以满足其需求。 每个空间 surface 网格提供的索引和顶点数据与用于在所有新式渲染 Api 中呈现三角形网格的[顶点和索引缓冲区](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx)使用的布局相同。 不过, 有一个关键事实需要注意的是, 空间映射三角形具有**前后的缠绕顺序**。 每个三角形都用网格的索引缓冲区中的三个顶点索引表示, 当从**正面**查看三角形时, 这些索引会按**顺时针**顺序标识三角形的顶点。 空间 surface 网格的正面 (或外部) 对应于实际表面正面 (可见) 的位置。

如果 surface 观察器提供的益处三角形密度仍不足粗, 则应用程序应仅执行网格简化, 这种工作的计算成本高昂, 并且已由运行时执行以生成各种提供的详细信息级别。

由于每个 surface 观察器都可以提供多个未连接的空间图面, 因此某些应用程序可能希望彼此剪裁这些空间 surface 网格, 然后将它们 zipper 在一起。 通常, 剪裁步骤是必需的, 因为附近的空间 surface 网格通常会稍微重叠。

## <a name="raycasting-and-collision"></a>Raycasting 和冲突

为了使物理 API (如[Havok](http://www.havok.com/)) 能够为空间图面提供具有 raycasting 和碰撞功能的应用程序, 应用程序必须向物理学 API 提供空间 surface 网格。 用于物理学的网格通常具有以下属性:
* 它们只包含少量三角形。 物理运算比呈现操作要多得多。
* 它们是 "水紧的"。 应为实心的表面不应具有小孔;即使洞太小, 也可能会导致问题。
* 它们将转换为凸 hulls。 凸 hulls 有几个多边形, 并且没有孔, 它们的计算效率比原始三角形网格要高得多。

针对空间图面执行 raycasts 时, 请记住, 这些图面通常是复杂的、杂乱的形状, 几乎不会有杂乱的细节, 就像您的办公桌一样! 这意味着, 单个 raycast 通常不能为您给出有关图面的形状和附近的空白空间形状的足够信息。 因此, 通常最好在一个较小的区域中执行许多 raycasts, 并使用聚合结果来更可靠地了解图面。 例如, 使用平均 10 raycasts 来指导图面上的全息影像布局将产生比只使用单个 raycast 更流畅和更小的 "抖动" 结果。

不过, 请记住, 每个 raycast 都有一个较高的计算成本。 因此, 根据使用方案, 你应将其他 raycasts (每个帧执行的计算成本) 的计算成本与[网格处理](spatial-mapping.md#mesh-processing)的计算成本进行权衡, 以平滑和删除空间图面中的孔 (当空间更新了网格)。

## <a name="troubleshooting"></a>疑难解答
* 为了使 surface 网格正确面向, 每个 GameObject 都需要处于活动状态, 然后才能将其发送到 SurfaceObeserver 来构造其网格。 否则, 网格将显示在您的空间中, 但会旋转为古怪度。
* 需要将运行与 SurfaceObserver 通信的脚本的 GameObject 设置为源。 否则, 你创建并发送到 SurfaceObserver 的所有 Gameobject 都具有与父游戏对象的偏移量相等的偏移量。 这会使你的网格显示多个计量仪, 这使得调试正在进行的操作非常困难。

## <a name="see-also"></a>请参阅
* [坐标系统](coordinate-systems.md)
* [DirectX 中的空间映射](spatial-mapping-in-directx.md)
* [Unity 中的空间映射](spatial-mapping-in-unity.md)
* [空间映射设计](spatial-mapping-design.md)
* [案例研究 - 看透现实中的洞](case-study-looking-through-holes-in-your-reality.md)
